<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Pornhub考虑收购Tumblr</title>
      <link href="/2019/11/29/pornhub/"/>
      <url>/2019/11/29/pornhub/</url>
      
        <content type="html"><![CDATA[<div class="entry clearfix">        <h1>Pornhub考虑收购Tumblr</h1>                <img alt="微博客" class="thumb lazyload" data-src="https://www.williamlong.info/logo/Microblog.gif">        <p>　　威瑞森电信（Verizon Communications）正在为轻博客社交网络平台Tumblr寻找买家，该公司正试图稳定难以实现收入目标的媒体业务。威瑞森媒体公司的前身是AOL和网络事业部门所属的母公司Oath。</p><p>　　Tumblr是一项拥有4亿多博客的免费服务，2013年，雅虎斥资约11亿美元收购了这家总部位于纽约的网站，当时它与图片社交网站Pinterest和新闻聚合网站Reddit等知名公司一样，是众多快速成长的初创公司之一。但Tumblr难以为雅虎创造有意义的收入，并被其他社交媒体，如Medium、和Instagram所超越。</p><p>　　《华尔街日报》报道说，最近几周，Verizon已经接触其它公司，它们可能想收购Tumblr。Tumblr目前有4.654亿篇博文和1720篇贴子。</p><p>　　Pornhub副总裁Carey Price在声明中说，他的公司很有兴趣买下Tumblr，非常期待能以NSFW内容（不适合上班时间浏览的内容）让平台恢复以前的光荣。</p><p>　　Tumblr从去年开始大力整治色情内容问题，造成流量下降，用户流失，Pornhub对此表示惋惜，并希望未来可以重现Tumblr的辉煌。</p><p>　　稿源：英国《每日邮报》</p></div>]]></content>
      
      
      <categories>
          
          <category> 吹牛逼 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Pornhub </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Steam中国正式定名“蒸汽平台”</title>
      <link href="/2019/11/27/Steam/"/>
      <url>/2019/11/27/Steam/</url>
      
        <content type="html"><![CDATA[<div class="entry clearfix">        <h1>Steam中国正式定名“蒸汽平台”</h1>          <p>　　8月21日，Steam中国终于正式定名，新名叫做：“蒸汽平台”。Steam中国（蒸汽平台）几乎完全独立于Steam，游戏库也将不断扩充，含VR游戏。首批上线的有包含《Dota2》《刀塔霸业》在内的近40款游戏。官方称，完美世界与美国Valve将在STEAM中国项目上密切合作。Steam全球其他已有的运营与服务不受影响。</p><p>　　完美中国表示，蒸汽平台专门为中国玩家打造，提供了高速服务器，高质量本地化等服务，同时也支持VR技术，并将逐渐构建海量精品游戏库。能满足不同口味玩家的需求。</p><p>　　本次发布会试玩环节，包括日本游戏厂商光荣特库摩的《三国志 14》、网易的《战意：前线》世嘉的《双点医院》等热门作品纷纷亮相，而诸如《欧洲卡车模拟 2》、《胡闹厨房 2》、《重生细胞》、《深海迷航》、《Raft》、《非常英雄》等众多独立作品也带来了不错的反响，让玩家对于平台正式推出时的作品充满期待。</p><p>　　除了大作和独立作品，蒸汽平台还将把更多 VR 内容带给国内玩家，这一点对于国内 VR 行业来说也是好事，一方面可以满足不同年龄和品味玩家的需求，另一方面对于内容创意者来说会是一个新的机会。</p><p style="text-align:center"><img alt="steam" data-src="/img/steam.jpg" class="lazyload"></p><p>　　国内目前 PC 玩家人数超过 3 亿人，根据 Niko Partners 的预测，到 2023 年 PC 玩家将超过 3.54 亿人，在 Steam 上，中国在全球数据流量占比达到 17.8%，超过美国 16.1% 成为世界第一，从数据上看，庞大的玩家群体需要更精细化的运营。</p><p>　　据介绍，蒸汽平台是Steam官方专门为中国玩家打造的，不仅提供了高速服务器，高质量本地化等服务，同时也将支持VR技术，并将逐渐构建海量精品游戏库，能最大化的满足不同玩家的各方面需求。</p><p>　　另外，早在去年完美世界Steam中国就已在上海浦东落户，形成产业集群，推动中国游戏和海外市场的交流。Steam平台是全球最大的综合性数字发行平台之一，其上游戏数量超过2万款。Steam平台将成为我国最大的电竞游戏聚合地，有利于中国电子竞技赛事版权的持续丰富。</p></div>]]></content>
      
      
      <categories>
          
          <category> 吹牛逼 </category>
          
          <category> 游戏 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Steam </tag>
            
            <tag> Game </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot【快速入门】</title>
      <link href="/2019/11/07/SpringBoot%E5%85%A5%E9%97%A8/"/>
      <url>/2019/11/07/SpringBoot%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<!-- <div id="music163player">    <iframe allow="autoplay" frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=450 src="//music.163.com/outchain/player?type=1&id=2838069802&auto=1&height=430"></iframe></div> --><div id="topics">        <div class="post">            <h1 class="postTitle"><p><a id="cb_post_title_url" class="postTitle2">Spring Boot【快速入门】</a></p><p><img data-src="/img/springboot.png" class="lazyload"></p><h2 id="spring-boot-概述">Spring Boot 概述</h2><blockquote><p><strong>Build Anything with Spring Boot：</strong>Spring Boot is the starting point for building all Spring-based applications. Spring Boot is designed to get you up and running as quickly as possible, with minimal upfront configuration of Spring.</p></blockquote><p>上面是引自官网的一段话，大概是说： Spring Boot 是所有基于 Spring 开发的项目的起点。Spring Boot 的设计是为了让你尽可能快的跑起来 Spring 应用程序并且尽可能减少你的配置文件。</p><h4 id="什么是-spring-boot">什么是 Spring Boot</h4><ul><li>它使用 “习惯优于配置” （项目中存在大量的配置，此外还内置一个习惯性的配置，让你无须）的理念让你的项目快速运行起来。</li><li>它并不是什么新的框架，而是默认配置了很多框架的使用方式，就像 Maven 整合了所有的 jar 包一样，Spring Boot 整合了所有框架（引自：<a href="http://www.ityouknow.com/springboot/2016/01/06/springboot(%E4%B8%80)-%E5%85%A5%E9%97%A8%E7%AF%87.html" target="_blank" rel="noopener">springboot(一)：入门篇——纯洁的微笑</a>）</li></ul><h4 id="使用-spring-boot-有什么好处">使用 Spring Boot 有什么好处</h4><p>回顾我们之前的 SSM 项目，搭建过程还是比较繁琐的，需要：</p><ul><li>1）配置 web.xml，加载 spring 和 spring mvc</li><li>2）配置数据库连接、配置日志文件</li><li>3）配置家在配置文件的读取，开启注解</li><li>4）配置mapper文件</li><li><strong>.....</strong></li></ul><p>而使用 Spring Boot 来开发项目则只需要非常少的几个配置就可以搭建起来一个 Web 项目，并且利用 IDEA 可以自动生成生成，这简直是太爽了...</p><ul><li>划重点：简单、快速、方便地搭建项目；对主流开发框架的无配置集成；极大提高了开发、部署效率。</li></ul><hr><h2 id="spring-boot-快速搭建">Spring Boot 快速搭建</h2><h4 id="第一步新建项目">第一步：新建项目</h4><p>选择 Spring Initializr ，然后选择默认的 url 点击【Next】：</p><p><img data-src="https://images.weserv.nl/?url=upload-images.jianshu.io/upload_images/7896890-3e2c9c5742c10c86.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" class="lazyload"></p><p>然后修改一下项目的信息：</p><p><img data-src="https://images.weserv.nl/?url=upload-images.jianshu.io/upload_images/7896890-28dbe478ff25a3a0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" class="lazyload"></p><p>勾选上 Web 模板：</p><p><img data-src="https://images.weserv.nl/?url=upload-images.jianshu.io/upload_images/7896890-532868b7e6760e03.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" class="lazyload"></p><p>选择好项目的位置，点击【Finish】：</p><p><img data-src="https://images.weserv.nl/?url=upload-images.jianshu.io/upload_images/7896890-931cc2fb5c8964e9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" class="lazyload"></p><p>如果是第一次配置 Spring Boot 的话可能需要等待一会儿 IDEA 下载相应的 依赖包，默认创建好的项目结构如下：</p><p><img data-src="https://images.weserv.nl/?url=upload-images.jianshu.io/upload_images/7896890-9ac7acc56d5a32f0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" class="lazyload"></p><p>项目结构还是看上去挺清爽的，少了很多配置文件，我们来了解一下默认生成的有什么：</p><ul><li>SpringbootApplication： 一个带有 main() 方法的类，用于启动应用程序</li><li>SpringbootApplicationTests：一个空的 Junit 测试了，它加载了一个使用 Spring Boot 字典配置功能的 Spring 应用程序上下文</li><li>application.properties：一个空的 properties 文件，可以根据需要添加配置属性</li><li>pom.xml： Maven 构建说明文件</li></ul><h4 id="第二步hellocontroller">第二步：HelloController</h4><p>在【cn.wmyskxz.springboot】包下新建一个【HelloController】：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">package cn.wmyskxz.springboot;</span><br><span class="line"></span><br><span class="line">import org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 测试控制器</span><br><span class="line"> *</span><br><span class="line"> * @author: @niko</span><br><span class="line"> * @create: 2018-05-08-下午 16:46</span><br><span class="line"> */</span><br><span class="line">@RestController</span><br><span class="line">public class HelloController &#123;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(&quot;/hello&quot;)</span><br><span class="line">    public String hello() &#123;</span><br><span class="line">        return &quot;Hello Spring Boot!&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>@RestController 注解：</strong> 该注解是 @Controller 和 @ResponseBody 注解的合体版</li></ul><h4 id="第三步利用-idea-启动-spring-boot">第三步：利用 IDEA 启动 Spring Boot</h4><p>我们回到 SpringbootApplication 这个类中，然后右键点击运行：</p><p><img data-src="https://images.weserv.nl/?url=upload-images.jianshu.io/upload_images/7896890-bf1aa6ed5c0db7b4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" class="lazyload"></p><ul><li><strong>注意</strong>：我们之所以在上面的项目中没有手动的去配置 Tomcat 服务器，是因为 Spring Boot 内置了 Tomcat</li></ul><p>等待一会儿就会看到下方的成功运行的提示信息：</p><p><img data-src="https://images.weserv.nl/?url=upload-images.jianshu.io/upload_images/7896890-63e43dc6a277de3e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" class="lazyload"></p><p>可以看到我们的 Tomcat 运行在 8080 端口，我们来访问 “<code>/hello</code>” 地址试一下：</p><p><img data-src="https://images.weserv.nl/?url=upload-images.jianshu.io/upload_images/7896890-6111e1913c5bf6d6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" class="lazyload"></p><p>可以看到页面成功显示出我们返回的信息。</p><hr><h2 id="解析-spring-boot-项目">解析 Spring Boot 项目</h2><blockquote><p>这一部分参考自：<a href="http://tengj.top/2017/02/26/springboot1/" target="_blank" rel="noopener">Spring Boot干货系列（一）优雅的入门篇 ——嘟嘟独立博客</a></p></blockquote><h4 id="解析-pom.xml-文件">解析 pom.xml 文件</h4><p>让我们来看看默认生成的 pom.xml 文件中到底有一些什么特别：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">    xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;</span><br><span class="line">    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line"></span><br><span class="line">    &lt;groupId&gt;cn.wmyskxz&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;springboot&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;</span><br><span class="line">    &lt;packaging&gt;jar&lt;/packaging&gt;</span><br><span class="line"></span><br><span class="line">    &lt;name&gt;springboot&lt;/name&gt;</span><br><span class="line">    &lt;description&gt;Demo project for Spring Boot&lt;/description&gt;</span><br><span class="line"></span><br><span class="line">    &lt;parent&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;2.0.1.RELEASE&lt;/version&gt;</span><br><span class="line">        &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;</span><br><span class="line">    &lt;/parent&gt;</span><br><span class="line"></span><br><span class="line">    &lt;properties&gt;</span><br><span class="line">        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;</span><br><span class="line">        &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt;</span><br><span class="line">        &lt;java.version&gt;1.8&lt;/java.version&gt;</span><br><span class="line">    &lt;/properties&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">            &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line"></span><br><span class="line">    &lt;build&gt;</span><br><span class="line">        &lt;plugins&gt;</span><br><span class="line">            &lt;plugin&gt;</span><br><span class="line">                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">            &lt;/plugin&gt;</span><br><span class="line">        &lt;/plugins&gt;</span><br><span class="line">    &lt;/build&gt;</span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure><p>我们可以看到一个比较陌生一些的标签 <code>&lt;parent&gt;</code> ，这个标签是在配置 Spring Boot 的父级依赖：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;parent&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.0.1.RELEASE&lt;/version&gt;</span><br><span class="line">    &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;</span><br><span class="line">&lt;/parent&gt;</span><br></pre></td></tr></table></figure><p>有了这个，当前的项目才是 Spring Boot 项目，spring-boot-starter-parent 是一个特殊的 starter ，它用来提供相关的 Maven 默认依赖，<strong>使用它之后，常用的包依赖就可以省去 version 标签。</strong></p><p>关于具体 Spring Boot 提供了哪些 jar 包的依赖，我们可以查看本地 Maven 仓库下：\repository\org\springframework\boot\spring-boot-dependencies\2.0.1.RELEASE\spring-boot-dependencies-2.0.1.RELEASE.pom 文件来查看，挺长的...</p><h4 id="应用入口类">应用入口类</h4><p>Spring Boot 项目通常有一个名为 *Application 的入口类，入口类里有一个 main 方法， <strong>这个 main 方法其实就是一个标准的 Javay 应用的入口方法。</strong></p><p><strong>@SpringBootApplication</strong> 是 Spring Boot 的核心注解，它是一个组合注解，该注解组合了：<strong>@Configuration、@EnableAutoConfiguration、@ComponentScan；</strong> 若不是用 @SpringBootApplication 注解也可以使用这三个注解代替。</p><ul><li>其中，<strong>@EnableAutoConfiguration 让 Spring Boot 根据类路径中的 jar 包依赖为当前项目进行自动配置</strong>，例如，添加了 spring-boot-starter-web 依赖，会自动添加 Tomcat 和 Spring MVC 的依赖，那么 Spring Boot 会对 Tomcat 和 Spring MVC 进行自动配置。</li><li><strong>Spring Boot 还会自动扫描 @SpringBootApplication 所在类的同级包以及下级包里的 Bean</strong> ，所以入口类建议就配置在 grounpID + arctifactID 组合的包名下（这里为 cn.wmyskxz.springboot 包）</li></ul><h4 id="spring-boot-的配置文件">Spring Boot 的配置文件</h4><p>Spring Boot 使用一个全局的配置文件 application.properties 或 application.yml，放置在【src/main/resources】目录或者类路径的 /config 下。</p><p>Spring Boot 不仅支持常规的 properties 配置文件，还支持 yaml 语言的配置文件。yaml 是以数据为中心的语言，在配置数据的时候具有面向对象的特征。</p><p>Spring Boot 的全局配置文件的作用是对一些默认配置的配置值进行修改。</p><blockquote><ul><li>简单实例一下</li></ul></blockquote><p><img data-src="https://images.weserv.nl/?url=upload-images.jianshu.io/upload_images/7896890-bcd65f7469b06608.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" class="lazyload"></p><p>我们同样的将 Tomcat 默认端口设置为 8080 ，并将默认的访问路径从 “<code>/</code>” 修改为 “<code>/hello</code>” 时，使用 properties 文件和 yml 文件的区别如上图。</p><ul><li>注意： yml 需要在 “<code>:</code>” 后加一个空格，幸好 IDEA 很好地支持了 yml 文件的格式有良好的代码提示；</li></ul><blockquote><ul><li>我们可以自己配置多个属性</li></ul></blockquote><p>我们直接把 .properties 后缀的文件删掉，使用 .yml 文件来进行简单的配置，然后使用 @Value 来获取配置属性：</p><p><img data-src="https://images.weserv.nl/?url=upload-images.jianshu.io/upload_images/7896890-0e808a82254d6a4b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" class="lazyload"></p><p>重启 Spring Boot ，输入地址：localhost:8080/hello 能看到正确的结果：</p><p><img data-src="https://images.weserv.nl/?url=upload-images.jianshu.io/upload_images/7896890-c85216e8ea7910f0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" class="lazyload"></p><ul><li><strong>注意：</strong> 我们并没有在 yml 文件中注明属性的类型，而是在使用的时候定义的。</li></ul><p>你也可以在配置文件中使用当前配置：</p><p><img data-src="https://images.weserv.nl/?url=upload-images.jianshu.io/upload_images/7896890-37e91abbc4550982.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" class="lazyload"></p><p>仍然可以得到正确的结果：</p><p><img data-src="https://images.weserv.nl/?url=upload-images.jianshu.io/upload_images/7896890-eabc3cd39b44fd0d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" class="lazyload"></p><ul><li><strong>问题：</strong> 这样写配置文件繁琐而且可能会造成类的臃肿，因为有许许多多的 @Value 注解。</li></ul><blockquote><ul><li>封装配置信息</li></ul></blockquote><p><img data-src="https://images.weserv.nl/?url=upload-images.jianshu.io/upload_images/7896890-2599817d8f2f50d2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" class="lazyload"></p><p>我们可以把配置信息封装成一个类，首先在我们的 name 和 age 前加一个 student 前缀，然后新建一个 StudentProperties 的类用来封装这些信息，并用上两个注解：</p><ul><li>@Component：表明当前类是一个 Java Bean</li><li>@ConfigurationProperties(prefix = "student")：表示获取前缀为 sutdent 的配置信息</li></ul><p>这样我们就可以在控制器中使用，重启得到正确信息：</p><p><img data-src="https://images.weserv.nl/?url=upload-images.jianshu.io/upload_images/7896890-84dc1215d01f3fa9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" class="lazyload"></p><h4 id="spring-boot-热部署">Spring Boot 热部署</h4><p>在目前的 Spring Boot 项目中，当发生了任何修改之后我们都需要重新启动才能够正确的得到效果，这样会略显麻烦，Spring Boot 提供了热部署的方式，当发现任何类发生了改变，就会通过 JVM 类加载的方式，加载最新的类到虚拟机中，这样就不需要重新启动也能看到修改后的效果了。</p><blockquote><ul><li>做法也很简单，修改 pom.xml 即可！</li></ul></blockquote><p>我们往 pom.xml 中添加一个依赖就可以了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;</span><br><span class="line">    &lt;optional&gt;true&lt;/optional&gt; &lt;!-- 这个需要为 true 热部署才有效 --&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>重新启动 Spring Boot ，然后修改任意代码，就能观察到控制台的自动重启现象：</p><p><img data-src="https://images.weserv.nl/?url=upload-images.jianshu.io/upload_images/7896890-cec869956c3cf158.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" class="lazyload"></p><blockquote><p>关于如何在 IDEA 中配置热部署：<a href="https://blog.csdn.net/xusheng_Mr/article/details/78771746" target="_blank" rel="noopener">传送门</a></p></blockquote><hr><h2 id="spring-boot-使用">Spring Boot 使用</h2><p>上面已经完成了 Spring Boot 项目的简单搭建，我们仅仅需要进行一些简单的设置，写一个 HelloController 就能够直接运行了，不要太简单...接下来我们再深入了解一下 Spring Boot 的使用。</p><h4 id="spring-boot-支持-jsp">Spring Boot 支持 JSP</h4><p>Spring Boot 的默认视图支持是 Thymeleaf 模板引擎，但是这个我们不熟悉啊，我们还是想要使用 JSP 怎么办呢？</p><blockquote><ul><li>第一步：修改 pom.xml 增加对 JSP 文件的支持</li></ul></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- servlet依赖. --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;javax.servlet&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;</span><br><span class="line">    &lt;scope&gt;provided&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;javax.servlet&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;jstl&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;!– tomcat的支持.–&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.tomcat.embed&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;tomcat-embed-jasper&lt;/artifactId&gt;</span><br><span class="line">    &lt;scope&gt;provided&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><blockquote><ul><li>第二步：配置试图重定向 JSP 文件的位置</li></ul></blockquote><p>修改 application.yml 文件，将我们的 JSP 文件重定向到 /WEB-INF/views/ 目录下：</p><p><img data-src="https://images.weserv.nl/?url=upload-images.jianshu.io/upload_images/7896890-7c17f7e10cfb2629.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" class="lazyload"></p><blockquote><ul><li>第三步：修改 HelloController</li></ul></blockquote><p>修改 @RestController 注解为 @Controller ，然后将 hello 方法修改为：</p><p><img data-src="https://images.weserv.nl/?url=upload-images.jianshu.io/upload_images/7896890-2dc2c39cd962edc1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" class="lazyload"></p><blockquote><ul><li>第四步：新建 hello.jsp 文件</li></ul></blockquote><p>在【src/main】目录下依次创建 webapp、WEB-INF、views 目录，并创建一个 hello.jsp 文件：</p><p><img data-src="https://images.weserv.nl/?url=upload-images.jianshu.io/upload_images/7896890-a180556d7ead9605.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" class="lazyload"></p><blockquote><ul><li>第五步：刷新网页</li></ul></blockquote><p>因为我们部署了热部署功能，所以只需要等待控制台重启信息完成之后再刷新网页就可以看到正确效果了：</p><p><img data-src="https://images.weserv.nl/?url=upload-images.jianshu.io/upload_images/7896890-cfd20f747ffca978.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" class="lazyload"></p><ul><li>关于 404，使用 spring-boot:run 运行项目可以解决：</li></ul><p><img data-src="https://images.weserv.nl/?url=upload-images.jianshu.io/upload_images/7896890-27c1bf46487ba5eb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" class="lazyload"></p><h4 id="集成-mybatis">集成 MyBatis</h4><blockquote><ul><li>第一步：修改 pom.xml 增加对 MySql和 MyBatis 的支持</li></ul></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- mybatis --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.1.1&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;!-- mysql --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;5.1.21&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><blockquote><ul><li>第二步：新增数据库链接参数</li></ul></blockquote><p>这里我们就直接使用之前创建好的 student 表了吧：</p><p><img data-src="https://images.weserv.nl/?url=upload-images.jianshu.io/upload_images/7896890-1eda563cfdfbae65.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" class="lazyload"></p><blockquote><ul><li>第三步：创建 Student 实体类和 StudentMapper 映射类</li></ul></blockquote><p>在【cn.wmyskxz.springboot】下新建一个【pojo】包，然后在其下创建一个 Student 类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class Student &#123;</span><br><span class="line"></span><br><span class="line">&lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt; Integer id;</span><br><span class="line">&lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt; Integer student_id;</span><br><span class="line">&lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;String&lt;/span&gt; name;</span><br><span class="line">&lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt; Integer age;</span><br><span class="line">&lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;String&lt;/span&gt; sex;</span><br><span class="line">&lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;Date&lt;/span&gt; birthday;</span><br><span class="line"></span><br><span class="line">/* getter &lt;span class=&quot;hljs-keyword&quot;&gt;and&lt;/span&gt; setter */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在【cn.wmyskxz.springboot】下新建一个【mapper】包，然后在其下创建一个 StudentMapper 映射类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">package cn.wmyskxz.springboot.mapper;</span><br><span class="line"></span><br><span class="line">import cn.wmyskxz.springboot.pojo.Student;</span><br><span class="line">import org.apache.ibatis.annotations.Mapper;</span><br><span class="line">import org.apache.ibatis.annotations.Select;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@Mapper</span><br><span class="line">public interface StudentMapper &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;span class=&quot;hljs-meta&quot;&gt;@Select&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;SELECT * FROM student&quot;&lt;/span&gt;)</span><br><span class="line">&lt;span class=&quot;hljs-function&quot;&gt;List&amp;lt;Student&amp;gt; &lt;span class=&quot;hljs-title&quot;&gt;findAll&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ul><li>第四步：编写 StudentController</li></ul></blockquote><p>在【cn.wmyskxz.springboot】下新建一个【controller】包，然后在其下创建一个 StudentController ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">package cn.wmyskxz.springboot.controller;</span><br><span class="line"></span><br><span class="line">import cn.wmyskxz.springboot.mapper.StudentMapper;</span><br><span class="line">import cn.wmyskxz.springboot.pojo.Student;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.stereotype.Controller;</span><br><span class="line">import org.springframework.ui.Model;</span><br><span class="line">import org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Student 控制器</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@author: @我没有三颗心脏</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@create: 2018-05-08-下午 20:25</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/</span><br><span class="line">@Controller</span><br><span class="line">public class StudentController &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  @Autowired</span><br><span class="line">  StudentMapper studentMapper;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  @RequestMapping(“/listStudent”)</span><br><span class="line">  public String listStudent(Model model) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;span class=&quot;hljs-type&quot;&gt;List&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-type&quot;&gt;Student&lt;/span&gt;&amp;gt; students = studentMapper.findAll();</span><br><span class="line">model.addAttribute(&lt;span class=&quot;hljs-string&quot;&gt;&quot;students&quot;&lt;/span&gt;, students);</span><br><span class="line">&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;listStudent&quot;&lt;/span&gt;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>第五步：编写 listStudent.jsp 文件</p></blockquote><p>我们简化一下 JSP 的文件，仅显示两个字段的数据：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot;</span><br><span class="line">       pageEncoding=&quot;UTF-8&quot;%&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;%@ taglib uri=“http://java.sun.com/jsp/jstl/core&quot; prefix=“c”%&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;table align=‘center’ border=‘1’ cellspacing=‘0’&gt;</span><br><span class="line">    &lt;tr&gt;</span><br><span class="line">        &lt;td&gt;id&lt;/td&gt;</span><br><span class="line">        &lt;td&gt;name&lt;/td&gt;</span><br><span class="line">    &lt;/tr&gt;</span><br><span class="line">    &lt;c:forEach items=“$&#123;students&#125;” var=“s” varStatus=“st”&gt;</span><br><span class="line">        &lt;tr&gt;</span><br><span class="line">            &lt;td&gt;$&#123;s.id&#125;&lt;/td&gt;</span><br><span class="line">            &lt;td&gt;$&#123;s.name&#125;&lt;/td&gt;</span><br><span class="line">        &lt;/tr&gt;</span><br><span class="line">    &lt;/c:forEach&gt;</span><br><span class="line">&lt;/table&gt;</span><br></pre></td></tr></table></figure><blockquote><ul><li>第六步：重启服务器运行</li></ul></blockquote><p>因为往 pom.xml 中新增加了依赖的包，所以自动重启服务器没有作用，我们需要手动重启一次，然后在地址输入：localhost:8080/listStudent 查看效果：</p><p><img data-src="https://images.weserv.nl/?url=upload-images.jianshu.io/upload_images/7896890-5fd3c075d07b5840.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" class="lazyload"></p><blockquote><p>以上。</p></blockquote><hr></h1></div>        </div>]]></content>
      
      
      <categories>
          
          <category> 工作学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>漫话：什么是 https ?这应该是全网把 https 讲的最好的一篇文章了</title>
      <link href="/2019/11/04/%E4%BB%80%E4%B9%88%E6%98%AF%20https/"/>
      <url>/2019/11/04/%E4%BB%80%E4%B9%88%E6%98%AF%20https/</url>
      
        <content type="html"><![CDATA[<p>  #https</p><p>今天这篇文章，讲通过对话的形式，让你由浅入深着知道，为什么 Https 是安全的。</p><p><img alt data-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMueGlhb3podWFubGFuLmNvbS9waG90by8yMDE5LzAyMmJkOWNmM2VhNzU3ZjAxNDc3YzhjZWVlMDUzOGY1Lg?x-oss-process=image/format,png" class="lazyload"></p><p><img alt data-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMueGlhb3podWFubGFuLmNvbS9waG90by8yMDE5LzU1ZDVkZWRmYzFjNWM5YjcwY2MzZjJkZGNkNjlkZmFhLg?x-oss-process=image/format,png" class="lazyload"></p><p><img alt data-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMueGlhb3podWFubGFuLmNvbS9waG90by8yMDE5L2Q0YWQwOGI1YWIyZDlkZDUyYzM5ZWUzZTg5MGMxMDkwLg?x-oss-process=image/format,png" class="lazyload"></p><h2><a name="t0"></a><a id="_11"></a>一、对称加密</h2><p><img alt data-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMueGlhb3podWFubGFuLmNvbS9waG90by8yMDE5L2JiZjBiZmQ2NWQyNTk5Yzg1NjFlMmYyZmM5MDE3NjY3Lg?x-oss-process=image/format,png" class="lazyload"></p><p>一禅：在每次发送真实数据之前，服务器先生成一把密钥，然后先把密钥传输给客户端。之后服务器给客户端发送真实数据的时候，会用这把密钥对数据进行加密，客户端收到加密数据之后，用刚才收到的密钥进行解密。如图：</p><p><img alt data-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMueGlhb3podWFubGFuLmNvbS9waG90by8yMDE5L2U0YTUyYzIyYWU2OWEwMTgxYzE2ZTQ5NjA2MWIxZGFhLg?x-oss-process=image/format,png" class="lazyload"></p><p>当然，如果客户端要给服务器发送数据，也是采用这把密钥来加密，这里为了方便，我采用单方向传输的形式</p><p><img alt data-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMueGlhb3podWFubGFuLmNvbS9waG90by8yMDE5L2JiYWVjYjA2OWJkM2RlODEzYzJiN2JjYmFmNDg1ZDMyLg?x-oss-process=image/format,png" class="lazyload"></p><p><img alt data-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMueGlhb3podWFubGFuLmNvbS9waG90by8yMDE5L2QxN2M1YmFiNWRlZWU4OTBhYmEyODkxMzE3YmRhMmUyLg?x-oss-process=image/format,png" class="lazyload"></p><p><img alt data-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMueGlhb3podWFubGFuLmNvbS9waG90by8yMDE5LzhlYjIyNWI3NjJhMzYzZjVmYjMwMmYzYjhhMWY0MTFmLg?x-oss-process=image/format,png" class="lazyload"></p><p><img alt data-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMueGlhb3podWFubGFuLmNvbS9waG90by8yMDE5LzdkNTE0NzQ4YWEyNDNjYWJhMzFiNTAxZTE2NTBhNzM4Lg?x-oss-process=image/format,png" class="lazyload"></p><p>小白：那万一密钥在传输的过程中被别人截取了怎么吧?</p><p>例如：</p><p>假如服务器用明文的方式传输密钥给客户端，然后密钥被中间人给捕获了，那么在之后服务器和客户端的加密传输过程中，中间人也可以用他捕获的密钥进行解密。这样的话，加密的数据在中间人看来和明文没啥两样</p><p><img alt data-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMueGlhb3podWFubGFuLmNvbS9waG90by8yMDE5LzAxNTJmNzQ4NTk4MjE1Mzk2ZGJhOTdmNWI5ZDE3ZjNlLg?x-oss-process=image/format,png" class="lazyload"></p><p><img alt data-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMueGlhb3podWFubGFuLmNvbS9waG90by8yMDE5LzVhNjcxOGFhM2VhZjIwN2Y0NjAzNGU1MmNmZGMyYzg3Lg?x-oss-process=image/format,png" class="lazyload"></p><p><img alt data-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMueGlhb3podWFubGFuLmNvbS9waG90by8yMDE5L2JiNzNlMTBlNDY1OTc0YjY5NDBiNGQ3ZDNiNzUwNTlkLg?x-oss-process=image/format,png" class="lazyload"></p><p><img alt data-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMueGlhb3podWFubGFuLmNvbS9waG90by8yMDE5LzE4MjJiMTUyMjkwZTAwOGUwMjIxMGFjYzZmYTIzYjNjLg?x-oss-process=image/format,png" class="lazyload"></p><p><img alt data-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMueGlhb3podWFubGFuLmNvbS9waG90by8yMDE5Lzk5MDU4YTU5YWNjMjE3OGY2NGY1MjgxOWJhODUxMDBlLg?x-oss-process=image/format,png" class="lazyload"></p><h2><a name="t1"></a><a id="_57"></a>二、非对称加密</h2><p><img alt data-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMueGlhb3podWFubGFuLmNvbS9waG90by8yMDE5LzE0MjIwOGZlZDM3MzQ1M2FjYTUzYzU3YWRjYzNkMmE0Lg?x-oss-process=image/format,png" class="lazyload"></p><p>一禅：这种方法就是，让客户端和服务器都拥有两把钥匙，一把钥匙是公开的(全世界知道都没关系)，我们称之为公钥；另一把钥匙则是保密的(只有自己本人才知道)，我们称之为私钥。这且，<strong>用公钥加密的数据，只有对应的私钥才能解密；用私钥加密的数据，只有对应的公钥才能解密</strong>。</p><p>这样，服务器在给客户端传输数据的过程中，可以用客户端明文给他的公钥进行加密，然后客户端收到后，再用自己的私钥进行解密。客户端给服务器发送数据的时候也一样采取这样的方式。这样就能保持数据的安全传输了。画个图理解一下：</p><p><img alt data-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMueGlhb3podWFubGFuLmNvbS9waG90by8yMDE5L2UwNzg1NmI4ODliZDU5NTQ1NWQ2MmViMmM3ZTc1ZjA0Lg?x-oss-process=image/format,png" class="lazyload"><br><img alt data-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMueGlhb3podWFubGFuLmNvbS9waG90by8yMDE5L2RhMTBjNzFhZTc0NjQwZmFmOGUwM2MxMmQ2Y2ZmYjMyLg?x-oss-process=image/format,png" class="lazyload"></p><p><img alt data-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMueGlhb3podWFubGFuLmNvbS9waG90by8yMDE5L2IwYTIwNzRhNGE0ZTk4ZmViZDgzMjhmMjkxNTc3N2EzLg?x-oss-process=image/format,png" class="lazyload"><br><img alt data-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMueGlhb3podWFubGFuLmNvbS9waG90by8yMDE5Lzc5NTdiZDZlM2ViM2NiMDkyMDk4YmM5YjA0NjQzODgxLg?x-oss-process=image/format,png" class="lazyload"></p><p><img alt data-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMueGlhb3podWFubGFuLmNvbS9waG90by8yMDE5LzgxYjk4ZTk3ODUzNjM4OGE3NmZmYmZiNWM3ZjM3NjczLg?x-oss-process=image/format,png" class="lazyload"></p><p><img alt data-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMueGlhb3podWFubGFuLmNvbS9waG90by8yMDE5LzQzZjMxNmU2NTdkMzdiMGY1YWU2MGE3MTllNGM3ZGM1Lg?x-oss-process=image/format,png" class="lazyload"></p><p><img alt data-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMueGlhb3podWFubGFuLmNvbS9waG90by8yMDE5LzkwZDM0ZGM1YzQzNjE2MWE2ZDY0ODg2MWEwM2U0ZWY0Lg?x-oss-process=image/format,png" class="lazyload"></p><p><img alt data-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMueGlhb3podWFubGFuLmNvbS9waG90by8yMDE5LzIwMWIyYzRhYjhkODg0YjQ0ZGJhNWFkZjY1NTJkOTNjLg?x-oss-process=image/format,png" class="lazyload"></p><p>一禅：处理方式就是结合 对称加密+非对称加密这两种方式，我们可以用非对称加密的方式来传输对称加密过程中的密钥，之后我们就可以采取对称加密的方式来传输数据了。具体是这样子的：</p><p>服务器用明文的方式给客户端发送自己的公钥，客户端收到公钥之后，会生成一把密钥(对称加密用的)，然后用服务器的公钥对这把密钥进行加密，之后再把密钥传输给服务器，服务器收到之后进行解密，最后服务器就可以安全着得到这把密钥了，而客户端也有同样一把密钥，他们就可以进行对称加密了。</p><p><img alt data-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMueGlhb3podWFubGFuLmNvbS9waG90by8yMDE5LzJmNjU0ZjFhMzdhOWZmOTgyMjBhYjNjMWMwYzhiYjFjLg?x-oss-process=image/format,png" class="lazyload"></p><p><img alt data-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMueGlhb3podWFubGFuLmNvbS9waG90by8yMDE5L2UxMTExYmYyMTE3OTVjNjQ1ZDgxMzJiZDlmYmY1NjAyLg?x-oss-process=image/format,png" class="lazyload"></p><p><img alt data-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMueGlhb3podWFubGFuLmNvbS9waG90by8yMDE5L2VkYTRmYjU5MDcwODY3Mzk0YmQwMTUwZTQzODAxZmMyLg?x-oss-process=image/format,png" class="lazyload"></p><p>小白：例如：</p><p>服务器以明文的方式给客户端传输公钥的时候，中间人截取了这把属于服务器的公钥，并且把中间人自己的公钥冒充服务器的公钥传输给了客户端。</p><p>之后客户端就会用中间人的公钥来加密自己生成的密钥。然后把被加密的密钥传输给服务器，这个时候中间人又把密钥给截取了，中间人用自己的私钥对这把被加密的密钥进行解密，解密后中间人就可以获得这把密钥了。</p><p>最后中间人再对这把密钥用刚才服务器的公钥进行加密，再发给服务器。如图：</p><p><img alt data-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMueGlhb3podWFubGFuLmNvbS9waG90by8yMDE5L2JkNGExZjBhYWU2ZjI2MDA0ZjE4NDRlMjFmMzkxZjg3Lg?x-oss-process=image/format,png" class="lazyload"></p><p>毫无疑问，在这个过程中，中间人获取了对称加密中的密钥，在之后服务器和客户端的对称加密传输中，这些加密的数据对中间人来说，和明文没啥区别。</p><p><img alt data-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMueGlhb3podWFubGFuLmNvbS9waG90by8yMDE5LzZlZWI4YzM0MzNjNzU1MDcxYTBhNDQyMDJmYTVmNzMyLg?x-oss-process=image/format,png" class="lazyload"></p><p><img alt data-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMueGlhb3podWFubGFuLmNvbS9waG90by8yMDE5LzVjOTViZTBhYmNmYmYzYTI2MDkyYTFjMDM2NmM2NmUyLg?x-oss-process=image/format,png" class="lazyload"></p><p><img alt data-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMueGlhb3podWFubGFuLmNvbS9waG90by8yMDE5L2U2ZGRhMWY5ZjE4ZmZjYTJmN2ZkNTA1MjIwMGU4YmIxLg?x-oss-process=image/format,png" class="lazyload"></p><p><img alt data-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMueGlhb3podWFubGFuLmNvbS9waG90by8yMDE5LzA5MmJlYjRjYjE1NGExN2YyNjk2Y2JlM2FiZjIwYWI5Lg?x-oss-process=image/format,png" class="lazyload"></p><p><img alt data-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMueGlhb3podWFubGFuLmNvbS9waG90by8yMDE5LzJmM2E0Y2U5NmE5ZTEyMzIwOTA2NzRiZjVjMTk2NTIxLg?x-oss-process=image/format,png" class="lazyload"></p><p><img alt data-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMueGlhb3podWFubGFuLmNvbS9waG90by8yMDE5LzUwODRiNmQzNzYxYTFkMTMyMDA0YTgwMDUxNjAxMzAwLg?x-oss-process=image/format,png" class="lazyload"></p><h2><a name="t2"></a><a id="_139"></a>数字证书登场</h2><p>在刚才的讲解中，我们知道，之所以非对称加密会不安全，是因为客户端不知道这把公钥是否是服务器的，因此，我们需要找到一种策略来证明这把公钥就是服务器的，而不是别人冒充的。</p><p>解决这个问题的方式就是使用数字证书，具体是这样的：</p><p>我们需要找到一个拥有公信力、大家都认可的<strong>认证中心(CA)</strong>。</p><p>服务器在给客户端传输公钥的过程中，会把公钥以及服务器的个人信息通过Hash算法生成<strong>信息摘要</strong>。如图</p><p><img alt data-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMueGlhb3podWFubGFuLmNvbS9waG90by8yMDE5L2Q2YWQxMTEyNjlhOWE4ODQ4N2NiZTQ0MDgxYzU0M2Q5Lg?x-oss-process=image/format,png" class="lazyload"></p><p>为了防止信息摘要被人调换，服务器还会用CA提供的私钥对信息摘要进行加密来形成<strong>数字签名</strong>。如图:</p><p><img alt data-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMueGlhb3podWFubGFuLmNvbS9waG90by8yMDE5Lzk2MTExY2M5M2NkOTk4YjE0OTNiODkyYTQxZDhhODcyLg?x-oss-process=image/format,png" class="lazyload"></p><p>并且，最后还会把原来没Hash算法之前的个人信息以及公钥 和 数字签名合并在一起，形成<strong>数字证书</strong>。如图</p><p><img alt data-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMueGlhb3podWFubGFuLmNvbS9waG90by8yMDE5L2RmNGFkYzM5Y2Y2YmEwYmUzODg4N2QwZjI1YjM3NWUwLg?x-oss-process=image/format,png" class="lazyload"></p><p>当客户端拿到这份数字证书之后，就会用CA提供的公钥来对数字证书里面的数字签名进行解密来得到信息摘要，然后对数字证书里服务器的公钥以及个人信息进行Hash得到<strong>另外一份信息摘要</strong>。最后把<strong>两份信息摘要进行对比</strong>，如果一样，则证明这个人是服务器，否则就不是。如图：</p><p><img alt data-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMueGlhb3podWFubGFuLmNvbS9waG90by8yMDE5LzIxMjk4NTVhNWUwNjM3N2MzZThhNDNkOTZmYTM4ZmYxLg?x-oss-process=image/format,png" class="lazyload"></p><p>这样，就可以保证服务器的公钥安全着交给客户端了。</p><p><img alt data-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMueGlhb3podWFubGFuLmNvbS9waG90by8yMDE5L2Y2ZjJkODY1MzBjOGJlMzdiMzU3ZTdhMzllMTU1MGU2Lg?x-oss-process=image/format,png" class="lazyload"></p><p><img alt data-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMueGlhb3podWFubGFuLmNvbS9waG90by8yMDE5L2Q0Mzc3OTAyN2JmMDkwZWJhNGVmYjhiMDM1MWViMWY3Lg?x-oss-process=image/format,png" class="lazyload"></p><p>其实，(有些)服务器一开始就向认证中心申请了这些证书了(有没有看过没有证书的网站在地址栏会被标出警告？)，而客户端是，也会内置这些证书。如图：</p><p><img alt data-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMueGlhb3podWFubGFuLmNvbS9waG90by8yMDE5LzE4NmE0YjcwNGViOWRhMWM2ZGMxMTYzMzdhMTlhMzFiLg?x-oss-process=image/format,png" class="lazyload"></p><p>当客户端收到服务器传输过来的数据数字证书时，就会在内置的证书列表里，查看是否有解开该数字证书的公钥，如果有则…，如果没有则…</p><p><img alt data-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMueGlhb3podWFubGFuLmNvbS9waG90by8yMDE5LzQwZjE2M2ZjMjg5YjU2MmE5Y2Q3NTNhMmMwYmU0NmU2Lg?x-oss-process=image/format,png" class="lazyload"></p><p><img alt data-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMueGlhb3podWFubGFuLmNvbS9waG90by8yMDE5LzI1M2ZiMWJhYTNkNWRhMzg1ZWNkYmJjOTdhMjJmNTJmLg?x-oss-process=image/format,png" class="lazyload"></p><h3><a name="t3"></a><a id="_195"></a>看完有收获？那么希望老铁别吝啬你的三连击哦</h3><p>1、<strong>点赞</strong>，可以让更多的人看到这篇文章<br>2、关注我的原创微信公众号『<strong>苦逼的码农</strong>』，第一时间阅读我的文章。公众号后台回复『电子书』，还送你一份电子书大礼包哦。<br>3、也欢迎关注我的博客哦。</p><h3><a name="t4"></a><a id="_200"></a><strong>作者简洁</strong></h3><blockquote><p>作者：帅地，一位热爱、认真写作的小伙，目前维护原创公众号：<strong>『苦逼的码农』</strong>，以写了150多篇文章，专注于写 <strong>算法</strong>、计算机基础知识等提升你内功的文章，期待你的关注。<br><strong>转载说明</strong>：务必注明来源（注明：来源于公众号：苦逼的码农， 作者：帅地）</p></blockquote><pre><code>                    &lt;/div&gt;&lt;link href=&quot;https://csdnimg.cn/release/phoenix/mdeditor/markdown_views-e9f16cbbc2.css&quot; rel=&quot;stylesheet&quot;&gt;    &lt;/div&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 吹牛逼 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> https </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SSM框架整合及搭建</title>
      <link href="/2019/11/04/SSM%E6%A1%86%E6%9E%B6%E6%95%B4%E5%90%88%E5%8F%8A%E6%90%AD%E5%BB%BA/"/>
      <url>/2019/11/04/SSM%E6%A1%86%E6%9E%B6%E6%95%B4%E5%90%88%E5%8F%8A%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<script src="https://cdn.jsdelivr.net/npm/jquery/dist/jquery.min.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome/css/font-awesome.min.css" /><!-- <script src="https://cdn.jsdelivr.net/gh/yujiajie01/live2d-widget@V11/autoloadx.js"></script> --><p>SSM框架整合及搭建<br>1、SpringMVC<br>    处理视图层前端请求及控制层接收请求后响应给客户端<br>2、Mybatis<br>    数据访问层</p><p>3、Spring<br>    IOC/DI<br>        控制反转、依赖注入<br>        处理层与层之间的依赖关系，进行解耦<br>    AOP<br>        面向切面编程<br>        处理日志、异常、事务</p><p>1、SpringMVC与Spring不需要整合<br>2、Mybatis与Spring整合数据访问<br>    1、dataSource    数据源<br>    2、SqlSessionFactory    会话工厂<br>    3、SqlSession    会话</p><p>框架搭建<br>1、导入jar包<br>    SpringMVC的jar包<br>    Mybatis的jar包<br>    Spring的jar包<br>    Mybatis与Spring集成的jar包</p><p>2、创建项目的包、创建实体类</p><p>3、添加SpringMVC环境<br>    1、添加SpringMVC核心配置文件 dispatcher-servlet.xml<br>        1) 添加注解的驱动支持，注解所在包的扫描</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 设置注解支持,扫描带有注解类的包 --&gt;</span><br><span class="line">&lt;context:component-scan base-package=&quot;controller,service.impl&quot; /&gt;</span><br><span class="line">&lt;mvc:annotation-driven /&gt;</span><br></pre></td></tr></table></figure><pre><code>2) 添加视图解析器</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 视图解析器 --&gt;</span><br><span class="line">   &lt;bean id=&quot;viewResolver&quot; class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot; &gt;</span><br><span class="line">&lt;!-- 属性名name,属性值value ,给class类的对象中的属性赋值 --&gt;</span><br><span class="line">&lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot;&gt;&lt;/property&gt;</span><br><span class="line">&lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;&gt;&lt;/property&gt;</span><br><span class="line">   &lt;/bean&gt;</span><br></pre></td></tr></table></figure><pre><code>3) 静态资源文件处理</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 处理静态资源文件 --&gt;</span><br><span class="line">&lt;mvc:resources location=&quot;/resource/&quot; mapping=&quot;/resource/**&quot; /&gt;</span><br></pre></td></tr></table></figure><p>2、配置web.xml<br>        1) 配置SpringMVC核心控制器及加载核心配置文件                </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 配置SpringMVC核心控制器 --&gt;</span><br><span class="line">&lt;servlet&gt;</span><br><span class="line">&lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt;</span><br><span class="line">&lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;</span><br><span class="line">&lt;init-param&gt;</span><br><span class="line">&lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;</span><br><span class="line">&lt;param-value&gt;classpath:dispatcher-servlet.xml&lt;/param-value&gt;</span><br><span class="line">&lt;/init-param&gt;</span><br><span class="line">&lt;/servlet&gt;</span><br><span class="line">&lt;servlet-mapping&gt;</span><br><span class="line">&lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt;</span><br><span class="line">&lt;url-pattern&gt;/&lt;/url-pattern&gt;</span><br><span class="line">&lt;/servlet-mapping&gt;</span><br></pre></td></tr></table></figure><p>3、创建Controller控制器<br>        1) 添加注解映射请求URL</p><p>4、创建JSP页面</p><p>4、Spring集成Mybatis<br>    1) 添加Mybatis环境<br>        添加配置文件mybatis-config.xml，配置文件中不再配置environments，其余的配置保留</p><p>2) 添加Spring配置文件applicationContext.xml<br>        将原有使用MyBatis进行数据访问的对象全部配置到Spring文件中</p><p>1) 数据源 - 第三方提供</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- dataSource 数据源-第三方 --&gt;</span><br><span class="line">&lt;bean id=&quot;dataSource&quot; class=&quot;org.apache.commons.dbcp.BasicDataSource&quot; &gt;</span><br><span class="line">&lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot; /&gt;</span><br><span class="line">&lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/house?useUnicode=true&amp;amp;characterEncoding=utf-8&quot; /&gt;</span><br><span class="line">&lt;property name=&quot;username&quot; value=&quot;root&quot; /&gt;</span><br><span class="line">&lt;property name=&quot;password&quot; value=&quot;123456&quot;/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><p>2) 会话工厂</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- sessionFactory 会话工厂集成 --&gt;</span><br><span class="line">&lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot; &gt;</span><br><span class="line">&lt;!-- 注入数据源dataSource --&gt;</span><br><span class="line">&lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt;</span><br><span class="line">&lt;!-- 注入Mybatis配置文件的路径 --&gt;</span><br><span class="line">&lt;property name=&quot;configLocation&quot; value=&quot;classpath:mybatis-config.xml&quot; /&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><p> 3) 会话</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- SqlSessionTemplate - Spring提供的会话模板 --&gt;</span><br><span class="line">&lt;bean id=&quot;sqlSessionTemplate&quot; class=&quot;org.mybatis.spring.SqlSessionTemplate&quot; &gt;</span><br><span class="line">&lt;!-- 只提供了 构造方法注入 --&gt;</span><br><span class="line">&lt;constructor-arg name=&quot;sqlSessionFactory&quot; ref=&quot;sqlSessionFactory&quot; /&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><p>5、衔接控制层与service层<br>    1) 在控制层和service层的实现类 加上注解<br>        1) controller层类的注解</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@Controller</span><br><span class="line">@RequestMapping(value=&quot;/user&quot;)</span><br><span class="line">public class LoginController</span><br></pre></td></tr></table></figure><p>2) service层类的注解</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@Service(&quot;userService&quot;)</span><br><span class="line">public class UserServiceImpl implements UserService</span><br></pre></td></tr></table></figure><p>3) 在controller层类中定义service接口作为其属性并通过注解注入该接口的实现类的实例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@Resource</span><br><span class="line">@Qualifier(&quot;userService&quot;)</span><br><span class="line">private UserService userService;</span><br></pre></td></tr></table></figure><p>2) 配置注解支持及扫描注解所在的包<br>    1) dispatcher-servlet.xml配置文件中添加如下配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 设置注解支持,扫描带有注解类的包 --&gt;</span><br><span class="line">&lt;context:component-scan base-package=&quot;controller,service.impl&quot; /&gt;</span><br><span class="line">&lt;mvc:annotation-driven /&gt;</span><br></pre></td></tr></table></figure><p>6、衔接service层与dao层<br>    service需要的是使用Spring容器中提供的sqlSessionTemplate会话模板, 所以service注入的是该会话模板对象<br>    由于sqlSessionTemplate已经在Spring的配置文件applicationContext.xml中定义了bean, 所以可以直接注入</p><p>1 在service类中定义属性sqlSessionTemplate </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private SqlSessionTemplate sqlSessionTemplate;</span><br></pre></td></tr></table></figure><p>2) 使用注解实现注入 </p><pre><code>@Resource@Qualifier(&quot;sqlSessionTemplate&quot;)private SqlSessionTemplate sqlSessionTemplate;</code></pre><p>7、web.xml中加载Spring配置文件applicationContext.xml<br>    由于sqlSessionTemplate在applicationContext.xml中定义的bean，当tomcat容器启动时就要完成controller注入service，<br>    service注入sqlSessionTemplate, 所以需要在web.xml中配置监听器加载applicationContext.xml配置文件, 这样tomcat容器在<br>    启动时会加载 dispatcher-servlet.xml 和 applicationCOntext.xml配置文件, 那么在客户端发起请求之前，这些注入全部都会<br>    提前完成。</p><pre><code>&lt;!-- Spring监听器 --&gt;&lt;context-param&gt;    &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;    &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt;&lt;/context-param&gt;&lt;listener&gt;    &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;&lt;/listener&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 工作学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ssm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ajax实现区域-街道多级联动</title>
      <link href="/2019/11/04/ajax%E5%AE%9E%E7%8E%B0%E5%8C%BA%E5%9F%9F-%E8%A1%97%E9%81%93%E5%A4%9A%E7%BA%A7%E8%81%94%E5%8A%A8/"/>
      <url>/2019/11/04/ajax%E5%AE%9E%E7%8E%B0%E5%8C%BA%E5%9F%9F-%E8%A1%97%E9%81%93%E5%A4%9A%E7%BA%A7%E8%81%94%E5%8A%A8/</url>
      
        <content type="html"><![CDATA[<script src="https://cdn.jsdelivr.net/npm/jquery/dist/jquery.min.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome/css/font-awesome.min.css" /><!-- <script src="https://cdn.jsdelivr.net/gh/yujiajie01/live2d-widget@V11/autoloadx.js"></script> --><p>前端代码示例：</p><pre><code>$(document).ready(function(){    $(&quot;#districtId&quot;).change(function(){        //清空下拉框街道的选项        $(&quot;#streetId option:gt(0)&quot;).remove();        //获取要发送的数据        var districtIdVal = $(&quot;#districtId&quot;).val();        //如果没有选择区不进行ajax请求        if(null == districtIdVal || &quot;&quot; ==  districtIdVal){            return;        }        //发送ajax请求        $.ajax({            &quot;url&quot;:&quot;&lt;%=path%&gt;/house/getStreetByAjax&quot;,    //请求的地址                            &quot;type&quot;:&quot;POST&quot;,    //发送请求的方式            &quot;data&quot;:{&quot;districtId&quot;:districtIdVal},        //发送的数据            &quot;dataType&quot;:&quot;json&quot;,        //定义服务端返回的数据格式            &quot;success&quot;:function(data){    //响应成功的回调函数                 for(var i=0; i&lt;data.length; i++){                    var street = data[i];                    //创建option元素节点                    var $option = $(&quot;&lt;option value=&apos;&quot;+street.id+&quot;&apos;&gt;&quot;+street.name+&quot;&lt;/option&gt;&quot;);                    //将新节点添加到select标签下                    $(&quot;#streetId&quot;).append($option);                 }            },            &quot;error&quot;:function(error){        //响应失败的回调函数                alert(&quot;请求失败:&quot; + error.status );            }        });    })})</code></pre><p>后台代码示例：</p><pre><code>/*@responseBody注解的作用是将controller的方法返回的对象通过适当的转换器转换为指定的格式之后，写入到response对象的body区，通常用来返回JSON数据或者是XML　　数据，需要注意的呢，在使用此注解之后不会再走试图处理器，而是直接将数据写入到输入流中，他的效果等同于通过response对象输出指定格式的数据。*/@ResponseBody@RequestMapping(value=&quot;/getStreetByAjax&quot;)public List&lt;TStreet&gt; getStreetByAjax(Long districtId){    System.out.println(&quot;id = &quot; + districtId);    List&lt;TStreet&gt; streets = districtService.getStreetByDistrictId(districtId);    return streets;}</code></pre><p>代码解析：</p><p>1、首先在区域(district)下拉列表绑定一个方法：当选项被改变时，执行以下步骤：<br>        1) 清空下拉框街道的选项(除了第一行)<br>        2) 获取用户选择的区域项的value值(就是了解用户选了哪个城区，好在后台查出这个市区对应的街道)<br>        3) 发送ajax请求(其实就是发送请求，和页面跳转、表单提交一个道理，只不过发出请求的不是整个页面，而是下拉框的个人行为，你可以这样理解)<br>        PS: $.ajax方法的参数，也就是括号里面的语句是json格式，写法是固定的，就是一行行键值对，键名是固定的属性，值的意思注释写了</p><p>2、前端代码的ajax请求被发送到后台，请求地址：<a href="http://localhost:8080/u3-springmvc-t66/house/getStreetByAjax" target="_blank" rel="noopener">http://localhost:8080/u3-springmvc-t66/house/getStreetByAjax</a><br>        并且request中有一个json类型的参数————用户选择的市区的value值，根据请求地址执行后台HouseController中的getStreetByAjax方法<br>        1) 通过入参的方式拿到request中的市区id<br>        2) 调用service层的districtService的方法，根据id从数据库拿到该市区的所有街道的list集合(由于我们还没有service层，这里只是模拟实现一下)<br>        3) 把这个list以json形式返回(由注解：@ResponseBody自动实现)</p><p>3、最后这个后台响应返回前端页面，则响应成功，继续执行”success”:中的回调函数<br>        1) 将json形式的后台返回的街道的list遍历<br>        2) 拿出每一个街道实体，每一个实体建立一个option标签<br>        3) 把这些标签一个个补到下拉框下面<br>        PS: 由于这些操作都只是下拉框的个人行为，当用户选择一个市区选项时，看到的页面本身没有变化，但实际上脚本已经把街道选项框重新组装</p>]]></content>
      
      
      <categories>
          
          <category> 工作学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ajax </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java详解jvm工作原理和流程</title>
      <link href="/2019/11/04/%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%92%8C%E6%B5%81%E7%A8%8B/"/>
      <url>/2019/11/04/%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%92%8C%E6%B5%81%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<script src="https://cdn.jsdelivr.net/npm/jquery/dist/jquery.min.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome/css/font-awesome.min.css"><!-- <script src="https://cdn.jsdelivr.net/gh/yujiajie01/live2d-widget@V11/autoloadx.js"></script> --><p>作为一名Java使用者，掌握JVM的体系结构也是必须的。<br>说起Java，人们首先想到的是Java编程语言，然而事实上，Java是一种技术，它由四方面组成：Java编程语言、Java类文件格式、Java虚拟机和Java应用程序接口(Java API)。它们的关系如下图所示：<br><img alt="这里写图片描述" data-src="https://img-blog.csdn.net/20131105235523390?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveF9wYW5kYQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" class="lazyload"></p><p>运行期环境代表着Java平台，开发人员编写Java代码(.java文件)，然后将之编译成字节码(.class文件)，再然后字节码被装入内存，一旦字节码进入虚拟机，它就会被解释器解释执行，或者是被即时代码发生器有选择的转换成机器码执行。</p><p>Java平台由Java虚拟机和Java应用程序接口搭建，Java语言则是进入这个平台的通道，用Java语言编写并编译的程序可以运行在这个平台上。这个平台的结构如下图所示：<br><img alt="这里写图片描述" data-src="https://img-blog.csdn.net/20131106000002718?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveF9wYW5kYQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" class="lazyload"></p><p>在Java平台的结构中, 可以看出，Java虚拟机(JVM) 处在核心的位置，是程序与底层操作系统和硬件无关的关键。它的下方是移植接口，移植接口由两部分组成：适配器和Java操作系统, 其中依赖于平台的部分称为适配器；JVM 通过移植接口在具体的平台和操作系统上实现；在JVM 的上方是Java的基本类库和扩展类库以及它们的API， 利用Java API编写的应用程序(application) 和小程序(Java applet) 可以在任何Java平台上运行而无需考虑底层平台, 就是因为有Java虚拟机(JVM)实现了程序与操作系统的分离，从而实现了Java 的平台无关性。 </p><p>JVM在它的生存周期中有一个明确的任务，那就是运行Java程序，因此当Java程序启动的时候，就产生JVM的一个实例；当程序运行结束的时候，该实例也跟着消失了。下面我们从JVM的体系结构和它的运行过程这两个方面来对它进行比较深入的研究。</p><p>1、Java虚拟机的体系结构</p><p>·每个JVM都有两种机制：</p><p>①类装载子系统：装载具有适合名称的类或接口</p><p>②执行引擎：负责执行包含在已装载的类或接口中的指令 </p><p>·每个JVM都包含：</p><p>方法区、Java堆、Java栈、本地方法栈、指令计数器及其他隐含寄存器</p><p><img alt="这里写图片描述" data-src="https://img-blog.csdn.net/20131113150006437?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveF9wYW5kYQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" class="lazyload"></p><p>对于JVM的学习，在我看来这么几个部分最重要：</p><p>Java代码编译和执行的整个过程<br>JVM内存管理及垃圾回收机制</p><p>下面分别对这几部分进行说明：</p><p>2、Java代码编译和执行的整个过程</p><p>也正如前面所说，Java代码的编译和执行的整个过程大概是：开发人员编写Java代码(.java文件)，然后将之编译成字节码(.class文件)，再然后字节码被装入内存，一旦字节码进入虚拟机，它就会被解释器解释执行，或者是被即时代码发生器有选择的转换成机器码执行。</p><p>（1）Java代码编译是由Java源码编译器来完成，也就是Java代码到JVM字节码（.class文件）的过程。 流程图如下所示：</p><p><img alt="这里写图片描述" data-src="https://img-blog.csdn.net/20131113150025609?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveF9wYW5kYQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" class="lazyload"></p><p>（2）Java字节码的执行是由JVM执行引擎来完成，流程图如下所示：</p><p><img alt="这里写图片描述" data-src="https://img-blog.csdn.net/20131113150058015?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveF9wYW5kYQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" class="lazyload"></p><p>Java代码编译和执行的整个过程包含了以下三个重要的机制:</p><p>·Java源码编译机制</p><p>·类加载机制</p><p>·类执行机制</p><p>（1）Java源码编译机制</p><p>Java 源码编译由以下三个过程组成：</p><p>①分析和输入到符号表</p><p>②注解处理</p><p>③语义分析和生成class文件</p><p>流程图如下所示：<br><img alt="这里写图片描述" data-src="https://img-blog.csdn.net/20131106003027687?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveF9wYW5kYQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" class="lazyload"></p><p>最后生成的class文件由以下部分组成：</p><p>①结构信息：包括class文件格式版本号及各部分的数量与大小的信息</p><p>②元数据：对应于Java源码中声明与常量的信息。包含类/继承的超类/实现的接口的声明信息、域与方法声明信息和常量池</p><p>③方法信息：对应Java源码中语句和表达式对应的信息。包含字节码、异常处理器表、求值栈与局部变量区大小、求值栈的类型记录、调试符号信息</p><p>（2）类加载机制<br>JVM的类加载是通过ClassLoader及其子类来完成的，类的层次关系和加载顺序可以由下图来描述：</p><p><img alt="这里写图片描述" data-src="https://img-blog.csdn.net/20131106003500328?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveF9wYW5kYQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" class="lazyload"></p><p>①Bootstrap ClassLoader</p><p>负责加载$JAVA_HOME中jre/lib/rt.jar里所有的class，由C++实现，不是ClassLoader子类</p><p>②Extension ClassLoader</p><p>负责加载java平台中扩展功能的一些jar包，包括$JAVA_HOME中jre/lib/*.jar或-Djava.ext.dirs指定目录下的jar包</p><p>③App ClassLoader</p><p>负责记载classpath中指定的jar包及目录中class</p><p>④Custom ClassLoader</p><p>属于应用程序根据自身需要自定义的ClassLoader，如tomcat、jboss都会根据j2ee规范自行实现ClassLoader</p><p>加载过程中会先检查类是否被已加载，检查顺序是自底向上，从Custom ClassLoader到BootStrap ClassLoader逐层检查，只要某个classloader已加载就视为已加载此类，保证此类只所有ClassLoader加载一次。而加载的顺序是自顶向下，也就是由上层来逐层尝试加载此类。</p><p>（3）类执行机制</p><p>JVM是基于堆栈的虚拟机。JVM为每个新创建的线程都分配一个堆栈.也就是说,对于一个Java程序来说，它的运行就是通过对堆栈的操作来完成的。堆栈以帧为单位保存线程的状态。JVM对堆栈只进行两种操作:以帧为单位的压栈和出栈操作。</p><p>JVM执行class字节码，线程创建后，都会产生程序计数器（PC）和栈（Stack），程序计数器存放下一条要执行的指令在方法内的偏移量，栈中存放一个个栈帧，每个栈帧对应着每个方法的每次调用，而栈帧又是有局部变量区和操作数栈两部分组成，局部变量区用于存放方法中的局部变量和参数，操作数栈中用于存放方法执行过程中产生的中间结果。栈的结构如下图所示：</p><p><img alt="这里写图片描述" data-src="https://img-blog.csdn.net/20131106003939906?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveF9wYW5kYQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" class="lazyload"></p><p>3、JVM内存管理及垃圾回收机制</p><p>JVM内存结构分为：方法区（method），栈内存（stack），堆内存（heap），本地方法栈（java中的jni调用），结构图如下所示：</p><p><img alt="这里写图片描述" data-src="https://img-blog.csdn.net/20131106010426437?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveF9wYW5kYQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" class="lazyload"><br>（1）堆内存（heap）</p><p>所有通过new创建的对象的内存都在堆中分配，其大小可以通过-Xmx和-Xms来控制。<br>操作系统有一个记录空闲内存地址的链表，当系统收到程序的申请时，会遍历该链表，寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲结点链表中删除，并将该结点的空间分配给程序，另外，对于大多数系统，会在这块内存空间中的首地址处记录本次分配的大小，这样代码中的delete语句才能正确的释放本内存空间。但由于找到的堆结点的大小不一定正好等于申请的大小，系统会自动的将多余的那部分重新放入空闲链表中。这时由new分配的内存，一般速度比较慢，而且容易产生内存碎片，不过用起来最方便。另外，在WINDOWS下，最好的方式是用VirtualAlloc分配内存，它不是在堆，也不是在栈，而是直接在进程的地址空间中保留一块内存，虽然这种方法用起来最不方便，但是速度快，也是最灵活的。堆内存是向高地址扩展的数据结构，是不连续的内存区域。由于系统是用链表来存储的空闲内存地址的，自然是不连续的，而链表的遍历方向是由低地址向高地址。堆的大小受限于计算机系统中有效的虚拟内存。由此可见，堆获得的空间比较灵活，也比较大。</p><p>（2）栈内存（stack）</p><p>在Windows下, 栈是向低地址扩展的数据结构，是一块连续的内存区域。这句话的意思是栈顶的地址和栈的最大容量是系统预先规定好的，在WINDOWS下，栈的大小是固定的（是一个编译时就确定的常数），如果申请的空间超过栈的剩余空间时，将提示overflow。因此，能从栈获得的空间较小。只要栈的剩余空间大于所申请空间，系统将为程序提供内存，否则将报异常提示栈溢出。 由系统自动分配，速度较快。但程序员是无法控制的。</p><p>堆内存与栈内存需要说明：</p><p>基础数据类型直接在栈空间分配，方法的形式参数，直接在栈空间分配，当方法调用完成后从栈空间回收。引用数据类型，需要用new来创建，既在栈空间分配一个地址空间，又在堆空间分配对象的类变量 。方法的引用参数，在栈空间分配一个地址空间，并指向堆空间的对象区，当方法调用完成后从栈空间回收。局部变量new出来时，在栈空间和堆空间中分配空间，当局部变量生命周期结束后，栈空间立刻被回收，堆空间区域等待GC回收。方法调用时传入的literal参数，先在栈空间分配，在方法调用完成后从栈空间收回。字符串常量、static在DATA区域分配，this在堆空间分配。数组既在栈空间分配数组名称，又在堆空间分配数组实际的大小。</p><p>如：</p><p><img alt="这里写图片描述" data-src="https://img-blog.csdn.net/20131106012403140?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveF9wYW5kYQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" class="lazyload"></p><p>（3）本地方法栈（java中的jni调用）</p><p>用于支持native方法的执行，存储了每个native方法调用的状态。对于本地方法接口，实现JVM并不要求一定要有它的支持，甚至可以完全没有。Sun公司实现Java本地接口(JNI)是出于可移植性的考虑，当然我们也可以设计出其它的本地接口来代替Sun公司的JNI。但是这些设计与实现是比较复杂的事情，需要确保垃圾回收器不会将那些正在被本地方法调用的对象释放掉。</p><p>（4）方法区（method）</p><p>它保存方法代码(编译后的java代码)和符号表。存放了要加载的类信息、静态变量、final类型的常量、属性和方法信息。JVM用持久代（Permanet Generation）来存放方法区，可通过-XX:PermSize和-XX:MaxPermSize来指定最小值和最大值。</p><p>垃圾回收机制</p><p>堆里聚集了所有由应用程序创建的对象，JVM也有对应的指令比如 new, newarray, anewarray和multianewarray，然并没有向 C++ 的 delete，free 等释放空间的指令，Java的所有释放都由 GC 来做，GC除了做回收内存之外，另外一个重要的工作就是内存的压缩，这个在其他的语言中也有类似的实现，相比 C++ 不仅好用，而且增加了安全性，当然她也有弊端，比如性能这个大问题。</p><p>4、Java虚拟机的运行过程示例</p><p>上面对虚拟机的各个部分进行了比较详细的说明，下面通过一个具体的例子来分析它的运行过程。</p><p>虚拟机通过调用某个指定类的方法main启动，传递给main一个字符串数组参数，使指定的类被装载，同时链接该类所使用的其它的类型，并且初始化它们。例如对于程序：</p><p><img alt="这里写图片描述" data-src="https://img-blog.csdn.net/20131106013916750?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveF9wYW5kYQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" class="lazyload"></p><p>编译后在命令行模式下键入： java HelloApp run virtual machine </p><p>将通过调用HelloApp的方法main来启动java虚拟机，传递给main一个包含三个字符串”run”、”virtual”、”machine”的数组。现在我们略述虚拟机在执行HelloApp时可能采取的步骤。</p><p>开始试图执行类HelloApp的main方法，发现该类并没有被装载，也就是说虚拟机当前不包含该类的二进制代表，于是虚拟机使用ClassLoader试图寻找这样的二进制代表。如果这个进程失败，则抛出一个异常。类被装载后同时在main方法被调用之前，必须对类HelloApp与其它类型进行链接然后初始化。链接包含三个阶段：检验，准备和解析。检验检查被装载的主类的符号和语义，准备则创建类或接口的静态域以及把这些域初始化为标准的默认值，解析负责检查主类对其它类或接口的符号引用，在这一步它是可选的。类的初始化是对类中声明的静态初始化函数和静态域的初始化构造方法的执行。一个类在初始化之前它的父类必须被初始化。整个过程如下：</p><p><img alt="这里写图片描述" data-src="https://img-blog.csdn.net/20131106014016937?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveF9wYW5kYQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" class="lazyload"></p>]]></content>
      
      
      <categories>
          
          <category> 工作学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>导出服务器上oracle数据</title>
      <link href="/2019/11/04/%E5%AF%BC%E5%87%BA%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8Aoracle%E6%95%B0%E6%8D%AE/"/>
      <url>/2019/11/04/%E5%AF%BC%E5%87%BA%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8Aoracle%E6%95%B0%E6%8D%AE/</url>
      
        <content type="html"><![CDATA[<script src="https://cdn.jsdelivr.net/npm/jquery/dist/jquery.min.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome/css/font-awesome.min.css" /><!-- <script src="https://cdn.jsdelivr.net/gh/yujiajie01/live2d-widget@V11/autoloadx.js"></script> --><h2 id="导出服务器上oracle数据"><a href="#导出服务器上oracle数据" class="headerlink" title="导出服务器上oracle数据"></a>导出服务器上oracle数据</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sqlplus / as  sysdba</span><br><span class="line"></span><br><span class="line">create user  test; identified by test;</span><br><span class="line"></span><br><span class="line">grant connect,resource,dba to test;</span><br><span class="line"></span><br><span class="line">exp test/test@XE file=d:\test.dmp full=y;</span><br></pre></td></tr></table></figure><p>2 将数据库中system用户与sys用户的表导出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exp system/manager@TEST file=d:\daochu.dmp owner=(system,sys)</span><br></pre></td></tr></table></figure><p>3 将数据库中的表table1 、table2导出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exp system/manager@TEST file=d:\daochu.dmp tables=(table1,table2)</span><br></pre></td></tr></table></figure><p>导入 （本地环境cmd）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">imp system/manager@TEST file=d:\daochu.dmp ignore=y</span><br><span class="line">imp system/manager@TEST file=d:\daochu.dmp tables=(table1) ignore=y</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 工作学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> oracle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>cluster（集群）nodejs 均衡负载</title>
      <link href="/2019/11/04/%E5%9D%87%E8%A1%A1%E8%B4%9F%E8%BD%BD/"/>
      <url>/2019/11/04/%E5%9D%87%E8%A1%A1%E8%B4%9F%E8%BD%BD/</url>
      
        <content type="html"><![CDATA[<script src="https://cdn.jsdelivr.net/npm/jquery/dist/jquery.min.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome/css/font-awesome.min.css" /><!-- <script src="https://cdn.jsdelivr.net/gh/yujiajie01/live2d-widget@V11/autoloadx.js"></script> --><p>Node.js在单个线程中运行单个实例。 用户(开发者)为了使用现在的多核系统，有时候,用户(开发者)会用一串Node.js进程去处理负载任务。</p><p>cluster 模块允许简单容易的创建共享服务器端口的子进程。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">const cluster = require(&apos;cluster&apos;);</span><br><span class="line">const http = require(&apos;http&apos;);</span><br><span class="line">const numCPUs = require(&apos;os&apos;).cpus().length;</span><br><span class="line"></span><br><span class="line">if (cluster.isMaster) &#123;</span><br><span class="line">  console.log(`主进程 $&#123;process.pid&#125; 正在运行`);</span><br><span class="line"></span><br><span class="line">  // 衍生工作进程。</span><br><span class="line">  for (let i = 0; i &lt; numCPUs; i++) &#123;</span><br><span class="line">    cluster.fork();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  cluster.on(&apos;exit&apos;, (worker, code, signal) =&gt; &#123;</span><br><span class="line">    console.log(`工作进程 $&#123;worker.process.pid&#125; 已退出`);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  // 工作进程可以共享任何 TCP 连接。</span><br><span class="line">  // 在本例子中，共享的是一个 HTTP 服务器。</span><br><span class="line">  http.createServer((req, res) =&gt; &#123;</span><br><span class="line">    res.writeHead(200);</span><br><span class="line">    res.end(&apos;你好世界\n&apos;);</span><br><span class="line">  &#125;).listen(8000);</span><br><span class="line"></span><br><span class="line">  console.log(`工作进程 $&#123;process.pid&#125; 已启动`);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在运行 Node.js 将会在工作进程(指代子进程)之间共享8000端口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ node server.js</span><br><span class="line">主进程 3596 正在运行</span><br><span class="line">工作进程 4324 已启动</span><br><span class="line">工作进程 4520 已启动</span><br><span class="line">工作进程 6056 已启动</span><br><span class="line">工作进程 5644 已启动</span><br></pre></td></tr></table></figure><p>请注意,在Windows中,还不能在工作进程中设置管道(Pipe)服务器。</p><p>工作原理</p><p>工作进程由child_process.fork()方法创建，因此它们可以使用IPC和父进程通信，从而使各进程交替处理连接服务。</p><p>cluster模块支持两种连接分发模式（将新连接安排给某一工作进程处理）。</p><p>第一种方法（也是除Windows外所有平台的默认方法），是循环法。由主进程负责监听端口，接收新连接后再将连接循环分发给工作进程。在分发中使用了一些内置技巧防止工作进程任务过载。</p><p>第二种方法是，主进程创建监听socket后发送给感兴趣的工作进程，由工作进程负责直接接收连接。</p><p>理论上第二种方法应该是效率最佳的，但在实际情况下，由于操作系统调度机制的难以捉摸，会使分发变得不稳定。我们遇到过这种情况：8个进程中的2个，分担了70%的负载。</p><p>因为server.listen()将大部分工作交给主进程完成，因此导致普通Node.js进程与cluster作业进程差异的情况有三种： 1. server.listen({fd: 7})由于文件描述符“7”是传递给父进程的，这个文件被监听后，将文件句柄（handle）传递给工作进程，而不是文件描述符“7”本身。 2. server.listen(handle) 明确监听句柄，会导致工作进程直接使用该句柄，而不是和父进程通信。 3. server.listen(0) 正常情况下，这种调用会导致server在随机端口上监听。但在cluster模式中，所有工作进程每次调用listen(0)时会收到相同的“随机”端口。实质上，这种端口只在第一次分配时随机，之后就变得可预料。如果要使用独立端口的话，应该根据工作进程的ID来生成端口号。</p><p>注意：Node.js不支持路由逻辑。因此在设计应用时，不应该过分依赖内存数据对象（如sessions和login等）。</p><p>由于各工作进程是独立的进程，它们可以根据需要随时关闭或重新生成，而不影响其他进程的正常运行。只要有存活的工作进程，服务器就可以继续处理连接。如果没有存活的工作进程，现有连接会丢失，新的连接也会被拒绝。Node.js不会自动管理工作进程的数量，而应该由具体的应用根据实际需要来管理进程池。</p><p>虽然cluster模块主要用于网络相关的情况，但同样可以用于其他需要worker进程的情况。</p>]]></content>
      
      
      <categories>
          
          <category> 工作学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> node </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo史上最全搭建教程</title>
      <link href="/2019/11/04/hexo%E5%8F%B2%E4%B8%8A%E6%9C%80%E5%85%A8%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B/"/>
      <url>/2019/11/04/hexo%E5%8F%B2%E4%B8%8A%E6%9C%80%E5%85%A8%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<script src="https://cdn.jsdelivr.net/npm/jquery/dist/jquery.min.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome/css/font-awesome.min.css"><!-- <script src="https://cdn.jsdelivr.net/gh/yujiajie01/live2d-widget@V11/autoloadx.js"></script> --><p>#hexo史上最全搭建教程</p><p>现在市面上的博客很多，如CSDN，博客园，简书等平台，可以直接在上面发表，用户交互做的好，写的文章百度也能搜索的到。缺点是比较不自由，会受到平台的各种限制和恶心的广告。</p><p>而自己购买域名和服务器，搭建博客的成本实在是太高了，不光是说这些购买成本，单单是花力气去自己搭这么一个网站，还要定期的维护它，对于我们大多数人来说，实在是没有这样的精力和时间。</p><p>那么就有第三种选择，直接在github page平台上托管我们的博客。这样就可以安心的来写作，又不需要定期维护，而且hexo作为一个快速简洁的博客框架，用它来搭建博客真的非常容易。</p><h2><a name="t0"></a><a id="Hexo_10"></a>Hexo简介</h2><p>Hexo是一款基于Node.js的静态博客框架，依赖少易于安装使用，可以方便的生成静态网页托管在GitHub和Coding上，是搭建博客的首选框架。大家可以进入<a href="https://hexo.io/zh-cn/" target="_blank" rel="nofollow noopener" data-token="566552a7a62a77832cb692c22280f61a">hexo官网</a>进行详细查看，因为Hexo的创建者是台湾人，对中文的支持很友好，可以选择中文进行查看。</p><p>教程分三个部分，</p><ul><li>第一部分：hexo的初级搭建还有部署到github page上，以及个人域名的绑定。</li><li>第二部分：hexo的基本配置，更换主题，实现多终端工作，以及在coding page部署实现国内外分流</li><li>第三部分：hexo添加各种功能，包括搜索的SEO，阅读量统计，访问量统计和评论系统等。</li></ul><hr><h1><a name="t1"></a><a id="_22"></a>第一部分</h1><p>hexo的初级搭建还有部署到github page上，以及个人域名的绑定。</p><h1><a name="t2"></a><a id="Hexo_27"></a>Hexo简介</h1><p>Hexo是一款基于Node.js的静态博客框架，依赖少易于安装使用，可以方便的生成静态网页托管在GitHub和Coding上，是搭建博客的首选框架。大家可以进入<a href="https://hexo.io/zh-cn/" target="_blank" rel="nofollow noopener" data-token="566552a7a62a77832cb692c22280f61a">hexo官网</a>进行详细查看，因为Hexo的创建者是台湾人，对中文的支持很友好，可以选择中文进行查看。</p><h1><a name="t3"></a><a id="Hexo_31"></a>Hexo搭建步骤</h1><ol><li>安装Git</li><li>安装Node.js</li><li>安装Hexo</li><li>GitHub创建个人仓库</li><li>生成SSH添加到GitHub</li><li>将hexo部署到GitHub</li><li>设置个人域名</li><li>发布文章</li></ol><h1><a name="t4"></a><a id="1_Git_42"></a>1. 安装Git</h1><p>Git是目前世界上最先进的分布式版本控制系统，可以有效、高速的处理从很小到非常大的项目版本管理。也就是用来管理你的hexo博客文章，上传到GitHub的工具。Git非常强大，我觉得建议每个人都去了解一下。廖雪峰老师的Git教程写的非常好，大家可以了解一下。<a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" target="_blank" rel="nofollow noopener" data-token="a7898ebe2baf3cae1521c34f89cd7516">Git教程</a></p><p>windows：到git官网上下载,<a href="https://gitforwindows.org/" target="_blank" rel="nofollow noopener" data-token="65cbc636381262947ae8b932fb62d669">Download git</a>,下载后会有一个Git Bash的命令行工具，以后就用这个工具来使用git。</p><p>linux：对linux来说实在是太简单了，因为最早的git就是在linux上编写的，只需要一行代码</p><pre class="prettyprint"><code class="has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;">sudo apt-get install git<div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style><li style="color: rgb(153, 153, 153);">1</li></ul></pre><p>安装好后，用<code>git --version</code> 来查看一下版本</p><h1><a name="t5"></a><a id="2_nodejs_58"></a>2. 安装nodejs</h1><p>Hexo是基于nodeJS编写的，所以需要安装一下nodeJs和里面的npm工具。</p><p>windows：<a href="https://nodejs.org/en/download/" target="_blank" rel="nofollow noopener" data-token="1ccdafce46a87ccfc591f0710f1c4f80">nodejs</a>选择LTS版本就行了。</p><p>linux：</p><pre class="prettyprint"><code class="prism language-shell has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;"><span class="token function">sudo</span> <span class="token function">apt-get</span> <span class="token function">install</span> nodejs<span class="token function">sudo</span> <span class="token function">apt-get</span> <span class="token function">install</span> <span class="token function">npm</span><div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li></ul></pre><p>安装完后，打开命令行</p><pre class="prettyprint"><code class="has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;">node -vnpm -v<div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li></ul></pre><p>检查一下有没有安装成功</p><p>顺便说一下，windows在git安装完后，就可以直接使用git bash来敲命令行了，不用自带的cmd，cmd有点难用。</p><h1><a name="t6"></a><a id="3_hexo_80"></a>3. 安装hexo</h1><p>前面git和nodejs安装好后，就可以安装hexo了，你可以先创建一个文件夹blog，然后<code>cd</code>到这个文件夹下（或者在这个文件夹下直接右键git bash打开）。</p><p>输入命令</p><pre class="prettyprint"><code class="has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;">npm install -g hexo-cli<div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style><li style="color: rgb(153, 153, 153);">1</li></ul></pre><p>依旧用<code>hexo -v</code>查看一下版本</p><p>至此就全部安装完了。</p><p>接下来初始化一下hexo</p><pre class="prettyprint"><code class="has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;">hexo init myblog<div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style><li style="color: rgb(153, 153, 153);">1</li></ul></pre><p>这个myblog可以自己取什么名字都行，然后</p><pre class="prettyprint"><code class="prism language-bash has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;"><span class="token function">cd</span> myblog //进入这个myblog文件夹<span class="token function">npm</span> <span class="token function">install</span><div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li></ul></pre><p>新建完成后，指定文件夹目录下有：</p><ul><li>node_modules: 依赖包</li><li>public：存放生成的页面</li><li>scaffolds：生成文章的一些模板</li><li>source：用来存放你的文章</li><li>themes：主题</li><li>** _config.yml: 博客的配置文件**</li></ul><pre class="prettyprint"><code class="has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;">hexo ghexo server<div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li></ul></pre><p>打开hexo的服务，在浏览器输入localhost:4000就可以看到你生成的博客了。</p><p>大概长这样：<br><img alt data-src="http://ww1.sinaimg.cn/large/d40b6c29gy1fvrksvj6e0j211c0f2n60.jpg" class="lazyload"><br>使用ctrl+c可以把服务关掉。</p><h1><a name="t7"></a><a id="4_GitHub_125"></a>4. GitHub创建个人仓库</h1><p>首先，你先要有一个GitHub账户，去注册一个吧。</p><p>注册完登录后，在GitHub.com中看到一个New repository，新建仓库<br><img alt data-src="http://ww1.sinaimg.cn/large/d40b6c29gy1fvrkstcm7ej20ei0c1aah.jpg" class="lazyload"></p><p>创建一个和你用户名相同的仓库，<a href="http://xn--yfr16an19l.github.io" target="_blank" rel="nofollow noopener" data-token="8a9cfed7ff8665d6939250ba12ba911f">后面加.github.io</a>，只有这样，将来要部署到GitHub page的时候，才会被识别，<a href="http://xn--xxxx-4m5f354ev5p.github.io" target="_blank" rel="nofollow noopener" data-token="29340eb4ad390b2f61cc7ca101505eec">也就是xxxx.github.io</a>，其中xxx就是你注册GitHub的用户名。我这里是已经建过了。</p><p><img alt data-src="http://ww1.sinaimg.cn/large/d40b6c29gy1fvrkstusrdj20iw0o4myp.jpg" class="lazyload"></p><p>点击create repository。</p><h1><a name="t8"></a><a id="5_SSHGitHub_141"></a>5. 生成SSH添加到GitHub</h1><p>回到你的git bash中，</p><pre class="prettyprint"><code class="has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;">git config --global user.name "yourname"git config --global user.email "youremail"<div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li></ul></pre><p>这里的yourname输入你的GitHub用户名，youremail输入你GitHub的邮箱。这样GitHub才能知道你是不是对应它的账户。</p><p>可以用以下两条，检查一下你有没有输对</p><pre class="prettyprint"><code class="has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;">git config user.namegit config user.email<div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li></ul></pre><p>然后创建SSH,一路回车</p><pre class="prettyprint"><code class="has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;">ssh-keygen -t rsa -C "youremail"<div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style><li style="color: rgb(153, 153, 153);">1</li></ul></pre><p>这个时候它会告诉你已经生成了.ssh的文件夹。在你的电脑中找到这个文件夹。</p><p><img alt data-src="http://ww1.sinaimg.cn/large/d40b6c29gy1fvrkstd106j20kb073gll.jpg" class="lazyload"></p><p>ssh，简单来讲，就是一个秘钥，其中，<code>id_rsa</code>是你这台电脑的私人秘钥，不能给别人看的，<code>id_rsa.pub</code>是公共秘钥，可以随便给别人看。把这个公钥放在GitHub上，这样当你链接GitHub自己的账户时，它就会根据公钥匹配你的私钥，当能够相互匹配时，才能够顺利的通过git上传你的文件到GitHub上。</p><p>而后在GitHub的setting中，找到SSH keys的设置选项，点击<code>New SSH key</code><br>把你的<code>id_rsa.pub</code>里面的信息复制进去。</p><p><img alt data-src="http://ww1.sinaimg.cn/large/d40b6c29gy1fvrkstdifaj210s0gfjrz.jpg" class="lazyload"></p><p>在gitbash中，查看是否成功</p><pre class="prettyprint"><code class="has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;">ssh -T git@github.com<div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style><li style="color: rgb(153, 153, 153);">1</li></ul></pre><h1><a name="t9"></a><a id="6_hexoGitHub_179"></a>6. 将hexo部署到GitHub</h1><p>这一步，我们就可以将hexo和GitHub关联起来，也就是将hexo生成的文章部署到GitHub上，打开站点配置文件 <code>_config.yml</code>，翻到最后，修改为<br>YourgithubName就是你的GitHub账户</p><pre class="prettyprint"><code class="has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;">deploy:  type: git  repo: https://github.com/YourgithubName/YourgithubName.github.io.git  branch: master<div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li><li style="color: rgb(153, 153, 153);">3</li><li style="color: rgb(153, 153, 153);">4</li></ul></pre><p>这个时候需要先安装deploy-git ，也就是部署的命令,这样你才能用命令部署到GitHub。</p><pre class="prettyprint"><code class="has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;">npm install hexo-deployer-git --save<div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style><li style="color: rgb(153, 153, 153);">1</li></ul></pre><p>然后</p><pre class="prettyprint"><code class="has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;">hexo cleanhexo generatehexo deploy<div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li><li style="color: rgb(153, 153, 153);">3</li></ul></pre><p>其中 <code>hexo clean</code>清除了你之前生成的东西，也可以不加。<br><code>hexo generate</code> 顾名思义，生成静态文章，可以用 <code>hexo g</code>缩写<br><code>hexo deploy</code> 部署文章，可以用<code>hexo d</code>缩写</p><p>注意deploy时可能要你输入username和password。</p><p>得到下图就说明部署成功了，过一会儿就可以在<code>http://yourname.github.io</code> 这个网站看到你的博客了！！<br><img alt data-src="http://ww1.sinaimg.cn/large/d40b6c29gy1fvrkstbtvfj20lq01u3yd.jpg" class="lazyload"></p><h1><a name="t10"></a><a id="7__211"></a>7. 设置个人域名</h1><p>现在你的个人网站的地址是 <code>yourname.github.io</code>，如果觉得这个网址逼格不太够，这就需要你设置个人域名了。但是需要花钱。</p><p>注册一个阿里云账户,在<a href="https://wanwang.aliyun.com/?spm=5176.8142029.digitalization.2.e9396d3e46JCc5" target="_blank" rel="nofollow noopener" data-token="d4fd2006cee1c75d664e7dba87778385">阿里云</a>上买一个域名，我买的是 <code>fangzh.top</code>，各个后缀的价格不太一样，比如最广泛的.com就比较贵，看个人喜好咯。</p><p>你需要先去进行实名认证,然后在域名控制台中，看到你购买的域名。</p><p>点<strong>解析</strong>进去，添加解析。</p><p><img alt data-src="http://ww1.sinaimg.cn/large/d40b6c29gy1fvrkstcu8xj20d607wdfw.jpg" class="lazyload"></p><p>其中，192.30.252.153 和 192.30.252.154 是GitHub的服务器地址。<br><strong>注意，解析线路选择默认</strong>，不要像我一样选境外。这个境外是后面来做国内外分流用的,在后面的博客中会讲到。记得现在选择<strong>默认</strong>！！</p><p><img alt data-src="http://ww1.sinaimg.cn/large/d40b6c29gy1fvrkstf8unj20ob05b0sq.jpg" class="lazyload"></p><p>登录GitHub，进入之前创建的仓库，点击settings，设置Custom domain，输入你的域名<code>fangzh.top</code></p><p><img alt data-src="http://ww1.sinaimg.cn/large/d40b6c29gy1fvrkstghklj20as04mt8n.jpg" class="lazyload"></p><p>然后在你的博客文件source中创建一个名为CNAME文件，不要后缀。写上你的域名。</p><p><img alt data-src="http://ww1.sinaimg.cn/large/d40b6c29gy1fvrkstgsyrj208806aq2z.jpg" class="lazyload"></p><p>最后，在gitbash中，输入</p><pre class="prettyprint"><code class="has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;">hexo cleanhexo ghexo d<div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li><li style="color: rgb(153, 153, 153);">3</li></ul></pre><p>过不了多久，再打开你的浏览器，输入你自己的域名，就可以看到搭建的网站啦！</p><p>接下来你就可以正式开始写文章了。</p><pre class="prettyprint"><code class="has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;">hexo new newpapername<div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style><li style="color: rgb(153, 153, 153);">1</li></ul></pre><p>然后在source/_post中打开markdown文件，就可以开始编辑了。当你写完的时候，再</p><pre class="prettyprint"><code class="has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;">hexo cleanhexo ghexo d<div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li><li style="color: rgb(153, 153, 153);">3</li></ul></pre><p>就可以看到更新了。</p><h1><a name="t11"></a><a id="_264"></a>第二部分</h1><p>hexo的基本配置，更换主题，实现多终端工作，以及在coding page部署实现国内外分流。</p><h1><a name="t12"></a><a id="1_hexo_269"></a>1. hexo基本配置</h1><p>在文件根目录下的<code>_config.yml</code>，就是整个hexo框架的配置文件了。可以在里面修改大部分的配置。详细可参考<a href="https://hexo.io/zh-cn/docs/configuration" target="_blank" rel="nofollow noopener" data-token="0cd9e96179b40d463ae472906f4a098b">官方的配置</a>描述。</p><h3><a name="t13"></a><a id="_275"></a>网站</h3><div class="table-box"><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td><code>title</code></td><td>网站标题</td></tr><tr><td><code>subtitle</code></td><td>网站副标题</td></tr><tr><td><code>description</code></td><td>网站描述</td></tr><tr><td><code>author</code></td><td>您的名字</td></tr><tr><td><code>language</code></td><td>网站使用的语言</td></tr><tr><td><code>timezone</code></td><td>网站时区。Hexo 默认使用您电脑的时区。<a href="https://en.wikipedia.org/wiki/List_of_tz_database_time_zones" target="_blank" rel="nofollow noopener" data-token="32f792257181ee0c25e2a967c7297faa">时区列表</a>。比如说：<code>America/New_York</code>, <code>Japan</code>, 和 <code>UTC</code> 。</td></tr></tbody></table></div><p>其中，<code>description</code>主要用于SEO，告诉搜索引擎一个关于您站点的简单描述，通常建议在其中包含您网站的关键词。<code>author</code>参数用于主题显示文章的作者。</p><h3><a name="t14"></a><a id="_290"></a>网址</h3><div class="table-box"><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td><code>url</code></td><td>网址</td></tr><tr><td><code>root</code></td><td>网站根目录</td></tr><tr><td><code>permalink</code></td><td>文章的 <a href="https://hexo.io/zh-cn/docs/permalinks" target="_blank" rel="nofollow noopener" data-token="79d8679b1fa8f4ab3a2e083ab4241c95">永久链接</a> 格式</td></tr><tr><td><code>permalink_defaults</code></td><td>永久链接中各部分的默认值</td></tr></tbody></table></div><p>在这里，你需要把<code>url</code>改成你的网站域名。</p><p>permalink，也就是你生成某个文章时的那个链接格式。</p><p>比如我新建一个文章叫<code>temp.md</code>，那么这个时候他自动生成的地址就是<code>http://yoursite.com/2018/09/05/temp</code>。</p><p>以下是官方给出的示例，关于链接的变量还有很多，需要的可以去官网上查找 <a href="https://hexo.io/zh-cn/docs/permalinks" target="_blank" rel="nofollow noopener" data-token="79d8679b1fa8f4ab3a2e083ab4241c95">永久链接</a> 。</p><div class="table-box"><table><thead><tr><th>参数</th><th>结果</th></tr></thead><tbody><tr><td><code>:year/:month/:day/:title/</code></td><td>2013/07/14/hello-world</td></tr><tr><td><code>:year-:month-:day-:title.html</code></td><td>2013-07-14-hello-world.html</td></tr><tr><td><code>:category/:title</code></td><td>foo/bar/hello-world</td></tr></tbody></table></div><p>再往下翻，中间这些都默认就好了。</p><pre class="prettyprint"><code class="has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;">theme: landscape<h1 id="Deployment"><a href="#Deployment" class="headerlink" title="Deployment"></a>Deployment</h1><h2 id="Docs-https-hexo-io-docs-deployment-html"><a href="#Docs-https-hexo-io-docs-deployment-html" class="headerlink" title="Docs: https://hexo.io/docs/deployment.html"></a>Docs: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">https://hexo.io/docs/deployment.html</a></h2><p>deploy:<br>  type: git<br>  repo: &lt;repository url&gt;<br>  branch: [branch]</p><div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li><li style="color: rgb(153, 153, 153);">3</li><li style="color: rgb(153, 153, 153);">4</li><li style="color: rgb(153, 153, 153);">5</li><li style="color: rgb(153, 153, 153);">6</li><li style="color: rgb(153, 153, 153);">7</li><li style="color: rgb(153, 153, 153);">8</li><li style="color: rgb(153, 153, 153);">9</li></ul></pre><p><code>theme</code>就是选择什么主题，也就是在<code>theme</code>这个文件夹下，在官网上有很多个主题，默认给你安装的是<code>lanscape</code>这个主题。当你需要更换主题时，在官网上下载，把主题的文件放在<code>theme</code>文件夹下，再修改这个参数就可以了。</p><p>接下来这个<code>deploy</code>就是网站的部署的，<code>repo</code>就是仓库(<code>Repository</code>)的简写。<code>branch</code>选择仓库的哪个分支。这个在之前进行github page部署的时候已经修改过了，不再赘述。而这个在后面进行双平台部署的时候会再次用到。</p><h3><a name="t15"></a><a id="Frontmatter_341"></a>Front-matter</h3><p>Front-matter 是文件最上方以 <code>---</code> 分隔的区域，用于指定个别文件的变量，举例来说：</p><pre class="prettyprint"><code class="has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;">title: Hello Worlddate: 2013/7/13 20:46:25---<div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li><li style="color: rgb(153, 153, 153);">3</li></ul></pre><p>下是预先定义的参数，您可在模板中使用这些参数值并加以利用。</p><div class="table-box"><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td><code>layout</code></td><td>布局</td></tr><tr><td><code>title</code></td><td>标题</td></tr><tr><td><code>date</code></td><td>建立日期</td></tr><tr><td><code>updated</code></td><td>更新日期</td></tr><tr><td><code>comments</code></td><td>开启文章的评论功能</td></tr><tr><td><code>tags</code></td><td>标签（不适用于分页）</td></tr><tr><td><code>categories</code></td><td>分类（不适用于分页）</td></tr><tr><td><code>permalink</code></td><td>覆盖文章网址</td></tr></tbody></table></div><p>其中，分类和标签需要区别一下，分类具有顺序性和层次性，也就是说 <code>Foo, Bar</code> 不等于 <code>Bar, Foo</code>；而标签没有顺序和层次。</p><pre class="prettyprint"><code class="has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;">categories:- Diarytags:- PS3- Games<div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li><li style="color: rgb(153, 153, 153);">3</li><li style="color: rgb(153, 153, 153);">4</li><li style="color: rgb(153, 153, 153);">5</li></ul></pre><h3><a name="t16"></a><a id="layout_376"></a>layout（布局）</h3><p>当你每一次使用代码</p><pre class="prettyprint"><code class="has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;">hexo new paper<div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style><li style="color: rgb(153, 153, 153);">1</li></ul></pre><p>它其实默认使用的是<code>post</code>这个布局，也就是在<code>source</code>文件夹下的<code>_post</code>里面。</p><p>Hexo 有三种默认布局：<code>post</code>、<code>page</code> 和 <code>draft</code>，它们分别对应不同的路径，而您自定义的其他布局和 <code>post</code> 相同，都将储存到 <code>source/_posts</code> 文件夹。</p><div class="table-box"><table><thead><tr><th>布局</th><th>路径</th></tr></thead><tbody><tr><td><code>post</code></td><td><code>source/_posts</code></td></tr><tr><td><code>page</code></td><td><code>source</code></td></tr><tr><td><code>draft</code></td><td><code>source/_drafts</code></td></tr></tbody></table></div><p>而new这个命令其实是：</p><pre class="prettyprint"><code class="has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;">hexo new [layout] &lt;title&gt;<div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style><li style="color: rgb(153, 153, 153);">1</li></ul></pre><p>只不过这个layout默认是post罢了。</p><h4><a id="page_404"></a>page</h4><p>如果你想另起一页，那么可以使用</p><pre class="prettyprint"><code class="has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;">hexo new page board<div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style><li style="color: rgb(153, 153, 153);">1</li></ul></pre><p>系统会自动给你在source文件夹下创建一个board文件夹，<a href="http://xn--boardindex-zt2p02eqgs45dlht758bqmyd.md" target="_blank" rel="nofollow noopener" data-token="4e64a53b8703e91bc2cf6f86b2772517">以及board文件夹中的index.md</a>，这样你访问的board对应的链接就是<code>http://xxx.xxx/board</code></p><h4><a id="draft_414"></a>draft</h4><p>draft是草稿的意思，也就是你如果想写文章，又不希望被看到，那么可以</p><pre class="prettyprint"><code class="has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;">hexo new draft newpage<div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style><li style="color: rgb(153, 153, 153);">1</li></ul></pre><p>这样会在source/_draft中新建一个newpage.md文件，如果你的草稿文件写的过程中，想要预览一下，那么可以使用</p><pre class="prettyprint"><code class="has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;">hexo server --draft<div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style><li style="color: rgb(153, 153, 153);">1</li></ul></pre><p>在本地端口中开启服务预览。</p><p>如果你的草稿文件写完了，想要发表到post中，</p><pre class="prettyprint"><code class="has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;">hexo publish draft newpage<div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style><li style="color: rgb(153, 153, 153);">1</li></ul></pre><p>就会自动把newpage.md发送到post中。</p><hr><h1><a name="t17"></a><a id="2__444"></a>2. 更换主题</h1><p>到这一步，如果你觉得默认的<code>landscape</code>主题不好看，那么可以在官网的主题中，选择你喜欢的一个主题进行修改就可以啦。<a href="https://hexo.io/themes/" target="_blank" rel="nofollow noopener" data-token="93c3a226a9dd6802027cf6c5a36b3180">点这里</a></p><p><img alt data-src="http://ww1.sinaimg.cn/large/d40b6c29gy1fvrkswpjhtj21fu0rhtp6.jpg" class="lazyload"></p><p>这里有200多个主题可以选。不过最受欢迎的就是那么几个，比如<a href="https://github.com/theme-next/hexo-theme-next" target="_blank" rel="nofollow noopener" data-token="b9e2454e695795db7584af6acfe17ba7">NexT主题</a>，非常的简洁好看，大多数人都选择这个，关于这个的教程也比较多。不过我选择的是<a href="https://github.com/ppoffice/hexo-theme-hueman" target="_blank" rel="nofollow noopener" data-token="7fd6d2eec71ae5b1ebd93695d162b8e5">hueman</a>这个主题，好像是从WordPress移植过来的，展示效果如下：</p><p><img alt data-src="http://ww1.sinaimg.cn/large/d40b6c29gy1fvrksxvknrj21fc0q8tsl.jpg" class="lazyload"></p><p>不管怎么样，至少是符合我个人的审美。</p><p>直接在github链接上下载下来，然后放到<code>theme</code>文件夹下就行了，然后再在刚才说的配置文件中把<code>theme</code>换成那个主题文件夹的名字，它就会自动在<code>theme</code>文件夹中搜索你配置的主题。</p><p>而后进入<code>hueman</code>这个文件夹，可以看到里面也有一个配置文件<code>_config.xml</code>，貌似它默认是<code>_config.xml.example</code>，把它复制一份，重命名为<code>_config.xml</code>就可以了。这个配置文件是修改你整个主题的配置文件。</p><h3><a name="t18"></a><a id="menu_466"></a>menu（菜单栏）</h3><p>也就是上面菜单栏上的这些东西。</p><p><img alt data-src="http://ww1.sinaimg.cn/large/d40b6c29gy1fvrkstfwjbj20jd0233ye.jpg" class="lazyload"></p><p>其中，About这个你是找不到网页的，因为你的文章中没有about这个东西。如果你想要的话，可以执行命令</p><pre class="prettyprint"><code class="has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;">hexo new page about<div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style><li style="color: rgb(153, 153, 153);">1</li></ul></pre><p>它就会在根目录下<code>source</code>文件夹中新建了一个<code>about</code>文件夹，<a href="http://xn--index-ok2hl60a.md" target="_blank" rel="nofollow noopener" data-token="8e35dc4dcc1b601bc7b92075c8c9ab97">以及index.md</a>，在index.md中写上你想要写的东西，就可以在网站上展示出来了。</p><p>如果你想要自己再自定义一个菜单栏的选项，那么就</p><pre class="prettyprint"><code class="has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;">hexo new page yourdiy<div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style><li style="color: rgb(153, 153, 153);">1</li></ul></pre><p>然后在主题配置文件的menu菜单栏添加一个 <code>Yourdiy : /yourdiy</code>，注意冒号后面要有空格，以及前面的空格要和menu中默认的保持整齐。然后在<code>languages</code>文件夹中，找到<code>zh-CN.yml</code>，在index中添加<code>yourdiy: '中文意思'</code>就可以显示中文了。</p><h3><a name="t19"></a><a id="customize_490"></a>customize(定制)</h3><p>在这里可以修改你的个人logo，默认是那个hueman，在<code>source/css/images</code>文件夹中放入自己要的logo，再改一下<code>url</code>的链接名字就可以了。</p><p><code>favicon</code>是网站中出现的那个小图标的icon，找一张你喜欢的logo，然后转换成ico格式，放在images文件夹下，配置一下路径就行。</p><p><code>social_links</code> ，可以显示你的社交链接，而且是有logo的。</p><p><strong>tips:</strong></p><p>在这里可以添加一个rss功能，也就是那个符号像wifi一样的东西。</p><h3><a name="t20"></a><a id="RSS_502"></a>添加RSS</h3><p><strong>1. 什么是RSS？</strong></p><p>RSS也就是订阅功能，你可以理解为类似与订阅公众号的功能，来订阅各种博客，杂志等等。</p><p><strong>2. 为什么要用RSS？</strong></p><p>就如同订阅公众号一样，你对某个公众号感兴趣，你总不可能一直时不时搜索这个公众号来看它的文章吧。博客也是一样，如果你喜欢某个博主，或者某个平台的内容，你可以通过RSS订阅它们，然后在RSS阅读器上可以实时推送这些消息。现在网上的垃圾消息太多了，如果你每一天都在看这些消息中度过，漫无目的的浏览，只会让你的时间一点一点的流逝，太不值得了。如果你关注的博主每次都发的消息都是精华，而且不是每一天十几条几十条的轰炸你，那么这个博主就值得你的关注，你就可以通过RSS订阅他。</p><p>在我的理解中，如果你不想每天都被那些没有质量的消息轰炸，只想安安静静的关注几个博主，每天看一些有质量的内容也不用太多，那么RSS订阅值得你的拥有。</p><p><strong>3. 添加RSS功能</strong></p><p>先安装RSS插件</p><pre class="prettyprint"><code class="has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;">npm i hexo-generator-feed<div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style><li style="color: rgb(153, 153, 153);">1</li></ul></pre><p>而后在你整个项目的<code>_config.yml</code>中找到Extensions，添加：</p><pre class="prettyprint"><code class="has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;"># Extensions## Plugins: https://hexo.io/plugins/#RSS订阅plugin:- hexo-generator-feed#Feed Atomfeed:  type: atom  path: atom.xml  limit: 20<div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li><li style="color: rgb(153, 153, 153);">3</li><li style="color: rgb(153, 153, 153);">4</li><li style="color: rgb(153, 153, 153);">5</li><li style="color: rgb(153, 153, 153);">6</li><li style="color: rgb(153, 153, 153);">7</li><li style="color: rgb(153, 153, 153);">8</li><li style="color: rgb(153, 153, 153);">9</li><li style="color: rgb(153, 153, 153);">10</li></ul></pre><p>这个时候你的RSS链接就是  域名<code>/atom.xml</code>了。</p><p>所以，在主题配置文件中的这个<code>social links</code>，开启RSS的页面功能，这样你网站上就有那个像wifi一样符号的RSS logo了，注意空格。</p><pre class="prettyprint"><code class="has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;">rss: /atom.xml<div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style><li style="color: rgb(153, 153, 153);">1</li></ul></pre><p><strong>4. 如何关注RSS？</strong></p><p>首先，你需要一个RSS阅读器，在这里我推荐<code>inoreader</code>，宇宙第一RSS阅读器，而且中文支持的挺好。不过它没有PC端的程序，只有网页版，chrome上有插件。在官网上用google账号或者自己注册账号登录，就可以开始你的关注之旅了。</p><p>每次需要关注某个博主时，就点开他的RSS链接，把链接复制到<code>inoreader</code>上，就能关注了，当然，如果是比较大众化的很厉害的博主，你直接搜名字也可以的，比如每个人都非常佩服的阮一峰大师，直接在阅读器上搜索<code>阮一峰</code>，应该就能出来了。</p><p>我关注的比如，阮一峰的网络日志，月光博客，知乎精选等，都很不错。当然，还有我！！赶快关注我吧！你值得拥有：<a href="http://fangzh.top/atom.xml" target="_blank" rel="nofollow noopener" data-token="1d365b8b8a72c69f7ac85d99cbcf993d">http://fangzh.top/atom.xml</a></p><p>在安卓端，inoreader也有下载，不过因为国内google是登录不了的，你需要在inoreader官网上把你的密码修改了，然后就可以用账户名和密码登录了。</p><p>在IOS端，没用过，好像是reader 3可以支持inoreader账户，还有个readon也不错，可以去试试。</p><h3><a name="t21"></a><a id="widgets_559"></a>widgets(侧边栏)</h3><p>侧边栏的小标签，如果你想自己增加一个，比如我增加了一个联系方式，那么我把<code>communication</code>写在上面，在<code>zh-CN.yml</code>中的<code>sidebar</code>，添加<code>communication: '中文'</code>。</p><p>然后在<code>hueman/layout/widget</code>中添加一个<code>communicaiton.ejs</code>，填入模板：</p><pre class="prettyprint"><code class="prism language-js has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;"><span class="token operator">&lt;</span><span class="token operator">%</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>site<span class="token punctuation">.</span>posts<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token operator">%</span><span class="token operator">&gt;</span>    <span class="token operator">&lt;</span>div <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"widget-wrap widget-list"</span><span class="token operator">&gt;</span>        <span class="token operator">&lt;</span>h3 <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"widget-title"</span><span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">%=</span> <span class="token function">__</span><span class="token punctuation">(</span><span class="token string">'sidebar.communiation'</span><span class="token punctuation">)</span> <span class="token operator">%</span><span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>h3<span class="token operator">&gt;</span>        <span class="token operator">&lt;</span>div <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"widget"</span><span class="token operator">&gt;</span>            <span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span>这里添加你要写的内容<span class="token operator">--</span><span class="token operator">&gt;</span>        <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>    <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">%</span> <span class="token punctuation">}</span> <span class="token operator">%</span><span class="token operator">&gt;</span><div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li><li style="color: rgb(153, 153, 153);">3</li><li style="color: rgb(153, 153, 153);">4</li><li style="color: rgb(153, 153, 153);">5</li><li style="color: rgb(153, 153, 153);">6</li><li style="color: rgb(153, 153, 153);">7</li><li style="color: rgb(153, 153, 153);">8</li></ul></pre><h3><a name="t22"></a><a id="search_578"></a>search(搜索框)</h3><p>默认搜索框是不能够用的，</p><blockquote><p>you need to install <code>hexo-generator-json-content</code> before using Insight Search</p></blockquote><p>它已经告诉你了，如果想要使用，就安装这个插件。</p><h3><a name="t23"></a><a id="comment_588"></a>comment(评论系统)</h3><p>这里的多数都是国外的，基本用不了。这个<code>valine</code>好像不错，还能统计文章阅读量，可以自己试一试，<a href="https://valine.js.org/quickstart.html#npm" target="_blank" rel="nofollow noopener" data-token="239a1af0bfb7fc6a90feb1702be74c2f">链接</a>。</p><h3><a name="t24"></a><a id="miscellaneous_594"></a>miscellaneous(其他)</h3><p>这里我就改了一个<code>links</code>，可以添加友链。注意空格要对！不然会报错！</p><h3><a name="t25"></a><a id="_600"></a>总结：</h3><p>整个主题看起来好像很复杂的样子，但是仔细捋一捋其实也比较流畅，</p><ul><li>languages: 顾名思义</li><li>layout：布局文件，其实后期想要修改自定义网站上的东西，添加各种各样的信息，主要是在这里修改，其中<code>comment</code>是评论系统，<code>common</code>是常规的布局，最常修改的在这里面，比如修改页面<code>head</code>和<code>footer</code>的内容。</li><li>scripts：js脚本，暂时没什么用</li><li>source：里面放了一些css的样式，以及图片</li></ul><hr><h1><a name="t26"></a><a id="3_git_613"></a>3. git分支进行多终端工作</h1><p>问题来了，如果你现在在自己的笔记本上写的博客，部署在了网站上，那么你在家里用台式机，或者实验室的台式机，发现你电脑里面没有博客的文件，或者要换电脑了，最后不知道怎么移动文件，怎么办？</p><p>在这里我们就可以利用git的分支系统进行多终端工作了，这样每次打开不一样的电脑，只需要进行简单的配置和在github上把文件同步下来，就可以无缝操作了。</p><h3><a name="t27"></a><a id="_623"></a>机制</h3><p>机制是这样的，由于<code>hexo d</code>上传部署到github的其实是hexo编译后的文件，是用来生成网页的，不包含源文件。</p><p><img alt="可以看到，并没有source等源文件在内" data-src="http://ww1.sinaimg.cn/large/d40b6c29gy1fvrkstj43xj20800d7glz.jpg" class="lazyload"></p><p>也就是上传的是在本地目录里自动生成的<code>.deploy_git</code>里面。</p><p>其他文件 ，包括我们写在source 里面的，和配置文件，主题文件，都没有上传到github</p><p><img alt data-src="http://ww1.sinaimg.cn/large/d40b6c29gy1fvrksthbryj20eb07swej.jpg" class="lazyload"></p><p>所以可以利用git的分支管理，将源文件上传到github的另一个分支即可。</p><h3><a name="t28"></a><a id="_645"></a>上传分支</h3><p>首先，先在github上新建一个hexo分支，如图：</p><p><img alt data-src="http://ww1.sinaimg.cn/large/d40b6c29gy1fvrkstkyz7j20cp0bgdg5.jpg" class="lazyload"></p><p>然后在这个仓库的settings中，选择默认分支为hexo分支（这样每次同步的时候就不用指定分支，比较方便）。</p><p><img alt data-src="http://ww1.sinaimg.cn/large/d40b6c29gy1fvrkstl8uxj20ql0dsgmo.jpg" class="lazyload"></p><p>然后在本地的任意目录下，打开git bash，</p><pre class="prettyprint"><code class="prism language-shell has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;"><span class="token function">git</span> clone git@github.com:ZJUFangzh/ZJUFangzh.github.io.git<div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style><li style="color: rgb(153, 153, 153);">1</li></ul></pre><p>将其克隆到本地，因为默认分支已经设成了hexo，所以clone时只clone了hexo。</p><p>接下来在克隆到本地的<code>ZJUFangzh.github.io</code>中，把除了.git 文件夹外的所有文件都删掉</p><p>把之前我们写的博客源文件全部复制过来，除了<code>.deploy_git</code>。这里应该说一句，复制过来的源文件应该有一个<code>.gitignore</code>，用来忽略一些不需要的文件，如果没有的话，自己新建一个，在里面写上如下，表示这些类型文件不需要git：</p><pre class="prettyprint"><code class="has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;">.DS_StoreThumbs.dbdb.json*.lognode_modules/public/.deploy*/<div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li><li style="color: rgb(153, 153, 153);">3</li><li style="color: rgb(153, 153, 153);">4</li><li style="color: rgb(153, 153, 153);">5</li><li style="color: rgb(153, 153, 153);">6</li><li style="color: rgb(153, 153, 153);">7</li></ul></pre><p>注意，如果你之前克隆过theme中的主题文件，那么应该把主题文件中的<code>.git</code>文件夹删掉，因为git不能嵌套上传，最好是显示隐藏文件，检查一下有没有，否则上传的时候会出错，导致你的主题文件无法上传，这样你的配置在别的电脑上就用不了了。</p><p>而后</p><pre class="prettyprint"><code class="prism language-shell has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;"><span class="token function">git</span> add <span class="token keyword">.</span><span class="token function">git</span> commit –m <span class="token string">"add branch"</span><span class="token function">git</span> push <div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li><li style="color: rgb(153, 153, 153);">3</li></ul></pre><p>这样就上传完了，可以去你的github上看一看hexo分支有没有上传上去，其中<code>node_modules</code>、<code>public</code>、<code>db.json</code>已经被忽略掉了，没有关系，不需要上传的，因为在别的电脑上需要重新输入命令安装 。</p><p><img alt data-src="http://ww1.sinaimg.cn/large/d40b6c29gy1fvrkstk4k1j20yq0h9gmr.jpg" class="lazyload"></p><p>这样就上传完了。</p><h3><a name="t29"></a><a id="_703"></a>更换电脑操作</h3><p>一样的，跟之前的环境搭建一样，</p><ul><li>安装git</li></ul><pre class="prettyprint"><code class="has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;">sudo apt-get install git<div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style><li style="color: rgb(153, 153, 153);">1</li></ul></pre><ul><li>设置git全局邮箱和用户名</li></ul><pre class="prettyprint"><code class="has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;">git config --global user.name "yourgithubname"git config --global user.email "yourgithubemail"<div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li></ul></pre><ul><li>设置ssh key</li></ul><pre class="prettyprint"><code class="has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;">ssh-keygen -t rsa -C "youremail"#生成后填到github和coding上（有coding平台的话）#验证是否成功ssh -T git@github.comssh -T git@git.coding.net #(有coding平台的话)<div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li><li style="color: rgb(153, 153, 153);">3</li><li style="color: rgb(153, 153, 153);">4</li><li style="color: rgb(153, 153, 153);">5</li></ul></pre><ul><li>安装nodejs</li></ul><pre class="prettyprint"><code class="has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;">sudo apt-get install nodejssudo apt-get install npm<div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li></ul></pre><ul><li>安装hexo</li></ul><pre class="prettyprint"><code class="has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;">sudo npm install hexo-cli -g<div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style><li style="color: rgb(153, 153, 153);">1</li></ul></pre><p>但是已经不需要初始化了，</p><p>直接在任意文件夹下，</p><pre class="prettyprint"><code class="has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;">git clone git@………………<div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style><li style="color: rgb(153, 153, 153);">1</li></ul></pre><p>然后进入克隆到的文件夹：</p><pre class="prettyprint"><code class="has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;">cd xxx.github.ionpm installnpm install hexo-deployer-git --save<div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li><li style="color: rgb(153, 153, 153);">3</li></ul></pre><p>生成，部署：</p><pre class="prettyprint"><code class="has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;">hexo ghexo d<div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li></ul></pre><p>然后就可以开始写你的新博客了</p><pre class="prettyprint"><code class="has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;">hexo new newpage<div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style><li style="color: rgb(153, 153, 153);">1</li></ul></pre><p><strong>Tips:</strong></p><ol><li>不要忘了，每次写完最好都把源文件上传一下</li></ol><pre class="prettyprint"><code class="has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;">git add .git commit –m "xxxx"git push <div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li><li style="color: rgb(153, 153, 153);">3</li></ul></pre><ol start="2"><li>如果是在已经编辑过的电脑上，已经有clone文件夹了，那么，每次只要和远端同步一下就行了</li></ol><pre class="prettyprint"><code class="has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;">git pull<div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style><li style="color: rgb(153, 153, 153);">1</li></ul></pre><hr><h1><a name="t30"></a><a id="4_coding_page_796"></a>4. coding page上部署实现国内外分流</h1><p>之前我们已经把hexo托管在github了，但是github是国外的，而且百度的爬虫是不能够爬取github的，所以如果你希望你做的博客能够在百度引擎上被收录，而且想要更快的访问，那么可以在国内的coding page做一个托管，这样在国内访问就是coding page，国外就走github page。</p><p><strong>1. 申请coding账户，新建项目</strong></p><p>先申请一个账户，然后创建新的项目，这一步项目名称应该是随意的。</p><p><strong>2.  添加ssh key</strong></p><p>这一步跟github一样。</p><p>添加后，检查一下是不是添加成功</p><pre class="prettyprint"><code class="has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;">ssh -T git@git.coding.net<div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style><li style="color: rgb(153, 153, 153);">1</li></ul></pre><p><strong>3. 修改_config.yml</strong></p><p>hexo官方文档是这样的：</p><pre class="prettyprint"><code class="has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;">deploy:  type: git  message: [message]  repo:    github: &lt;repository url&gt;,[branch]    coding: &lt;repository url&gt;,[branch] <div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li><li style="color: rgb(153, 153, 153);">3</li><li style="color: rgb(153, 153, 153);">4</li><li style="color: rgb(153, 153, 153);">5</li><li style="color: rgb(153, 153, 153);">6</li></ul></pre><p>那么，我们只需要：</p><pre class="prettyprint"><code class="has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;">deploy:  type: git  repo:     coding: git@git.coding.net:ZJUFangzh/ZJUFangzh.git,master    github: git@github.com:ZJUFangzh/ZJUFangzh.github.io.git,master<div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li><li style="color: rgb(153, 153, 153);">3</li><li style="color: rgb(153, 153, 153);">4</li><li style="color: rgb(153, 153, 153);">5</li></ul></pre><p><strong>4. 部署</strong></p><p>保存一下，直接</p><pre class="prettyprint"><code class="has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;">hexo ghexo d<div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li></ul></pre><p>这样就可以在coding的项目上看到你部署的文件了。</p><p><strong>5. 开启coding pages服务，绑定域名</strong></p><p>如图：</p><p><img alt data-src="http://ww1.sinaimg.cn/large/d40b6c29gy1fvrkstnswnj20xr0bugmj.jpg" class="lazyload"></p><p><strong>6. 阿里云添加解析</strong></p><p><img alt data-src="http://ww1.sinaimg.cn/large/d40b6c29gy1fvrkstjxu6j20o709bdg1.jpg" class="lazyload"></p><p>这个时候就可以把之前github的解析改成境外，把coding的解析设为默认了。</p><p><strong>7. 去除coding page的跳转广告</strong></p><p>coding page的一个比较恶心人的地方就是，你只是银牌会员的话，访问会先跳转到一个广告，再到你自己的域名。那么它也给出了消除的办法。右上角切换到coding的旧版界面，默认新版是不行的。然后再来到<code>pages服务</code>这里。</p><p>这里：</p><p><img alt data-src="http://ww1.sinaimg.cn/large/d40b6c29gy1fvrkstmpshj20j80cbmxq.jpg" class="lazyload"></p><p>只要你在页面上添加一行文字，写<code>Hosted by Coding Pages</code>，然后点下面的小勾勾，两个工作日内它就会审核通过了。</p><pre class="prettyprint"><code class="has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;">&lt;p&gt;Hosted by &lt;a href="https://pages.coding.me" style="font-weight: bold"&gt;Coding Pages&lt;/a&gt;&lt;/p&gt;<div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style><li style="color: rgb(153, 153, 153);">1</li></ul></pre><p>我的选择是把这一行代码放在主题文件夹<code>/layout/common/footer.ejs</code>里面，也就是本来在页面中看到的页脚部分。</p><p><img alt data-src="http://ww1.sinaimg.cn/large/d40b6c29gy1fvrkstk1skj20lh0630su.jpg" class="lazyload"></p><p>当然，为了统一，我又在后面加上了and <strong>Github</strong>哈哈，可以不加。</p><pre class="prettyprint"><code class="has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;">&lt;p&gt;&lt;span&gt;Hosted by &lt;a href="https://pages.coding.me" style="font-weight: bold"&gt;Coding Pages&lt;/a&gt;&lt;/span&gt; and &lt;span&gt;&lt;a href="https://github.com" style="font-weight: bold"&gt;Github&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;<div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style><li style="color: rgb(153, 153, 153);">1</li></ul></pre><p>这是最终加上去的代码。</p><hr><h1><a name="t31"></a><a id="_892"></a>第三部分</h1><p>hexo添加各种功能，包括搜索的SEO，阅读量统计，访问量统计和评论系统等。</p><p>本文参考了: <a href="http://visugar.com/2017/08/01/20170801HexoPlugins/" target="_blank" rel="nofollow noopener" data-token="04bb7ff1bd5e918a6ff005ece25f43ec">visugar.com</a>这里面说的很详细了。</p><h1><a name="t32"></a><a id="1_SEO_900"></a>1. SEO优化</h1><p>推广是很麻烦的事情，怎么样别人才能知道我们呢，首先需要让搜索引擎收录你的这个网站，别人才能搜索的到。那么这就需要SEO优化了。</p><blockquote><p>SEO是由英文Search Engine Optimization缩写而来， 中文意译为“搜索引擎优化”。SEO是指通过站内优化比如网站结构调整、网站内容建设、网站代码优化等以及站外优化。</p></blockquote><h3><a name="t33"></a><a id="seo_908"></a>百度seo</h3><p>刚建站的时候是没有搜索引擎收录我们的网站的。可以在搜索引擎中输入<code>site:&lt;域名&gt;</code></p><p>来查看一下。</p><p><strong>1. 登录百度站长平台添加网站</strong></p><p>登录<a href="https://ziyuan.baidu.com/linksubmit/index?" target="_blank" rel="nofollow noopener" data-token="d3a3e255150c5b678bf0fabaf10940e7">百度站长平台</a>，在站点管理中添加你自己的网站。</p><p>验证网站有三种方式：文件验证、HTML标签验证、CNAME验证。</p><p>第三种方式最简单，只要将它提供给你的那个xxxxx使用CNAME解析到xxx.baidu.com就可以了。也就是登录你的阿里云，把这个解析填进去就OK了。</p><p><strong>2. 提交链接</strong></p><p>我们需要使用npm自动生成网站的sitemap，然后将生成的sitemap提交到百度和其他搜索引擎</p><pre class="prettyprint"><code class="has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;">npm install hexo-generator-sitemap --save     npm install hexo-generator-baidu-sitemap --save<div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li></ul></pre><p>这时候你需要在你的根目录下<code>_config.xml</code>中看看url有没有改成你自己的：</p><p><img alt data-src="http://ww1.sinaimg.cn/large/d40b6c29gy1fvrkstpzd9j20ar03b749.jpg" class="lazyload"></p><p>重新部署后，就可以在public文件夹下看到生成的sitemap.xml和baidusitemap.xml了。</p><p>然后就可以向百度提交你的站点地图了。</p><p>这里建议使用自动提交。</p><p><img alt data-src="http://ww1.sinaimg.cn/large/d40b6c29gy1fvrkstwp4pj20fc0kyq4n.jpg" class="lazyload"></p><p>自动提交又分为三种：主动推送、自动推送、sitemap。</p><p>可以三个一起提交不要紧，我选择的是后两种。</p><ul><li>自动推送：把百度生成的自动推送代码，放在主题文件<code>/layout/common/head.ejs</code>的适当位置，然后验证一下就可以了。</li><li>sitemap：把两个sitemap地址，提交上去，看到状态正常就OK了。</li></ul><p><img alt data-src="http://ww1.sinaimg.cn/large/d40b6c29gy1fvrksu9fa6j20v60m4404.jpg" class="lazyload"></p><p><strong>ps:</strong> 百度收录比较慢，慢慢等个十天半个月再去<code>site:&lt;域名&gt;</code>看看有没有被收录。</p><h3><a name="t34"></a><a id="googleSEO_962"></a>google的SEO</h3><p>流程一样，google更简单，而且收录更快，进入<a href="https://search.google.com/search-console/sitemaps?resource_id=http://fangzh.top/&amp;hl=zh-CN" target="_blank" rel="nofollow noopener" data-token="aeecd3c3457815b3a71e3dbbe86ddef6">google站点地图</a>，提交网站和sitemap.xml，就可以了。</p><p>如果你这个域名在google这里出了问题，那你就提交 <a href="http://yourname.github.io" target="_blank" rel="nofollow noopener" data-token="327364c036ff71ba8281eaf5c00de66d">yourname.github.io</a>，这个链接，效果是一样的。</p><p>不出意外的话一天内google就能收录你的网站了。</p><p><img alt data-src="http://ww1.sinaimg.cn/large/d40b6c29gy1fvrkswrucmj20q30lkq72.jpg" class="lazyload"></p><p>其他的搜索，如搜狗搜索，360搜索，流程是一样的，这里就不再赘述。</p><h1><a name="t35"></a><a id="2__980"></a>2. 评论系统</h1><p>评论系统有很多，但是很多都是墙外的用不了，之前说过这个valine好像集成在hueman和next主题里面了，但是我还没有研究过，我看的是<a href="http://visugar.com/2017/08/01/20170801HexoPlugins/" target="_blank" rel="nofollow noopener" data-token="04bb7ff1bd5e918a6ff005ece25f43ec">visugar</a>这个博主用的来比力评论系统，感觉也还不错。</p><p><a href="https://livere.com/" target="_blank" rel="nofollow noopener" data-token="1b2d0c73266483a03b93d18e93f2e89f">来比力官网</a>，注册好后，点击管理页面，在<code>代码管理</code>中找到安装代码：</p><p><img alt data-src="http://ww1.sinaimg.cn/large/d40b6c29gy1fvrksu93vyj20tk0m440w.jpg" class="lazyload"></p><p>获取安装代码后，在主题的comment下新建一个文件放入刚刚那段代码，再找到article文件，找到如下代码，若没有则直接在footer后面添加即可。livebe即为刚刚所创文件名称。</p><pre class="prettyprint"><code class="has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;">&lt;%- partial('comment/livebe') %&gt;<div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style><li style="color: rgb(153, 153, 153);">1</li></ul></pre><p>然后可以自己设置一些东西：</p><p><img alt data-src="http://ww1.sinaimg.cn/large/d40b6c29gy1fvrksufavtj20v70o9mzw.jpg" class="lazyload"></p><p>还可以设置评论提醒，这样别人评论你的时候就可以及时知道了。</p><h1><a name="t36"></a><a id="3__1010"></a>3. 添加百度统计</h1><p>百度统计可以在后台上看到你网站的访问数，浏览量，浏览链接分布等很重要的信息。所以添加百度统计能更有效的让你掌握你的网站情况。</p><p><a href="https://tongji.baidu.com" target="_blank" rel="nofollow noopener" data-token="34ac545e25167ce230e8369822aac405">百度统计</a>，注册一下，这里的账号好像和百度账号不是一起的。</p><p><img alt data-src="http://ww1.sinaimg.cn/large/d40b6c29gy1fvrksvbdmwj20lf0kx78n.jpg" class="lazyload"></p><p>照样把代码复制到<code>head.ejs</code>文件中，然后再进行一下安装检查，半小时左右就可以在百度统计里面看到自己的网站信息了。</p><h1><a name="t37"></a><a id="4_leanCloud_1026"></a>4. 文章阅读量统计leanCloud</h1><p><a href="https://leancloud.cn/" target="_blank" rel="nofollow noopener" data-token="7f43b51103d0e74cad18e95b6e8d7194">leanCloud</a>，进去后注册一下，进入后创建一个应用：</p><p><img alt data-src="http://ww1.sinaimg.cn/large/d40b6c29gy1fvrkstp8rdj20h30cimxt.jpg" class="lazyload"></p><p>在<code>存储</code>中创建Class，命名为Counter,</p><p><img alt data-src="http://ww1.sinaimg.cn/large/d40b6c29gy1fvrkstygbpj20gq0k0abm.jpg" class="lazyload"></p><p>然后在设置页面看到你的<code>应用Key</code>，在主题的配置文件中：</p><pre class="prettyprint"><code class="has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;">leancloud_visitors:  enable: true  app_id: 你的id  app_key: 你的key<div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li><li style="color: rgb(153, 153, 153);">3</li><li style="color: rgb(153, 153, 153);">4</li></ul></pre><p>在<code>article.ejs</code>中适当的位置添加如下，这要看你让文章的阅读量统计显示在哪个地方了，</p><pre class="prettyprint"><code class="has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;">阅读数量:&lt;span id="&lt;%= url_for(post.path) %&gt;" class="leancloud_visitors" data-flag-title="&lt;%- post.title %&gt;"&gt;&lt;/span&gt;次<div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style><li style="color: rgb(153, 153, 153);">1</li></ul></pre><p>然后在<code>footer.ejs</code>的最后，添加：</p><pre class="prettyprint"><code class="has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;">&lt;script src="//cdn1.lncld.net/static/js/2.5.0/av-min.js"&gt;&lt;/script&gt;&lt;script&gt;    var APP_ID = '你的app id';    var APP_KEY = '你的app key';    AV.init({        appId: APP_ID,        appKey: APP_KEY    });    // 显示次数    function showTime(Counter) {        var query = new AV.Query("Counter");        if($(".leancloud_visitors").length &gt; 0){            var url = $(".leancloud_visitors").attr('id').trim();            // where field            query.equalTo("words", url);            // count            query.count().then(function (number) {                // There are number instances of MyClass where words equals url.                $(document.getElementById(url)).text(number?  number : '--');            }, function (error) {                // error is an instance of AVError.            });        }    }    // 追加pv    function addCount(Counter) {        var url = $(".leancloud_visitors").length &gt; 0 ? $(".leancloud_visitors").attr('id').trim() : 'icafebolger.com';        var Counter = AV.Object.extend("Counter");        var query = new Counter;        query.save({            words: url        }).then(function (object) {        })    }    $(function () {        var Counter = AV.Object.extend("Counter");        addCount(Counter);        showTime(Counter);    });&lt;/script&gt;<div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li><li style="color: rgb(153, 153, 153);">3</li><li style="color: rgb(153, 153, 153);">4</li><li style="color: rgb(153, 153, 153);">5</li><li style="color: rgb(153, 153, 153);">6</li><li style="color: rgb(153, 153, 153);">7</li><li style="color: rgb(153, 153, 153);">8</li><li style="color: rgb(153, 153, 153);">9</li><li style="color: rgb(153, 153, 153);">10</li><li style="color: rgb(153, 153, 153);">11</li><li style="color: rgb(153, 153, 153);">12</li><li style="color: rgb(153, 153, 153);">13</li><li style="color: rgb(153, 153, 153);">14</li><li style="color: rgb(153, 153, 153);">15</li><li style="color: rgb(153, 153, 153);">16</li><li style="color: rgb(153, 153, 153);">17</li><li style="color: rgb(153, 153, 153);">18</li><li style="color: rgb(153, 153, 153);">19</li><li style="color: rgb(153, 153, 153);">20</li><li style="color: rgb(153, 153, 153);">21</li><li style="color: rgb(153, 153, 153);">22</li><li style="color: rgb(153, 153, 153);">23</li><li style="color: rgb(153, 153, 153);">24</li><li style="color: rgb(153, 153, 153);">25</li><li style="color: rgb(153, 153, 153);">26</li><li style="color: rgb(153, 153, 153);">27</li><li style="color: rgb(153, 153, 153);">28</li><li style="color: rgb(153, 153, 153);">29</li><li style="color: rgb(153, 153, 153);">30</li><li style="color: rgb(153, 153, 153);">31</li><li style="color: rgb(153, 153, 153);">32</li><li style="color: rgb(153, 153, 153);">33</li><li style="color: rgb(153, 153, 153);">34</li><li style="color: rgb(153, 153, 153);">35</li><li style="color: rgb(153, 153, 153);">36</li><li style="color: rgb(153, 153, 153);">37</li><li style="color: rgb(153, 153, 153);">38</li><li style="color: rgb(153, 153, 153);">39</li><li style="color: rgb(153, 153, 153);">40</li></ul></pre><p>重新部署后就可以了。</p><h1><a name="t38"></a><a id="5__1110"></a>5. 引入不蒜子访问量和访问人次统计</h1><p>不蒜子的添加非常非常方便，<a href="http://busuanzi.ibruce.info/" target="_blank" rel="nofollow noopener" data-token="6c76b066a8f5016935e2e6afd230afcb">不蒜子</a></p><p>在<code>footer.ejs</code>中的合适位置，看你要显示在哪个地方，添加：</p><pre class="prettyprint"><code class="has-numbering" onclick="mdcp.copyCode(event)" style="position: unset;">&lt;!--这一段是不蒜子的访问量统计代码--&gt;&lt;script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"&gt;&lt;/script&gt;&lt;span id="busuanzi_container_site_pv"&gt;本站总访问量&lt;span id="busuanzi_value_site_pv"&gt;&lt;/span&gt;次 &amp;nbsp;   &lt;/span&gt;&lt;span id="busuanzi_container_site_uv"&gt;访客数&lt;span id="busuanzi_value_site_uv"&gt;&lt;/span&gt;人次&lt;/span&gt;<div class="hljs-button {2}" data-title="复制"></div></code><ul class="pre-numbering" style><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li><li style="color: rgb(153, 153, 153);">3</li><li style="color: rgb(153, 153, 153);">4</li></ul></pre><p>就可以了。</p><h1><a name="t39"></a><a id="_1127"></a>总结</h1><p>到这里就基本做完了。其实都是参考别的博主的设置的，不一定仅限于hueman主题，其他主题的设置也是大体相同的，所以如果你希望设置别的主题，那么仔细看一下这个主题的代码结构，也能够把上边的功能添加进去。</p><p>多看看别的博主的那些功能，如果有你能找到自己喜欢的功能，那么好好发动搜索技能，很快就能找到怎么做了。加油吧！</p><pre><code>                    &lt;/div&gt;&lt;link href=&quot;https://csdnimg.cn/release/phoenix/mdeditor/markdown_views-e9f16cbbc2.css&quot; rel=&quot;stylesheet&quot;&gt;    &lt;/div&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 工作学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>搭建个人ssr</title>
      <link href="/2019/11/01/%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BAssr/"/>
      <url>/2019/11/01/%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BAssr/</url>
      
        <content type="html"><![CDATA[<script src="https://cdn.jsdelivr.net/npm/jquery/dist/jquery.min.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome/css/font-awesome.min.css" /><!-- <script src="https://cdn.jsdelivr.net/gh/yujiajie01/live2d-widget@V11/autoloadx.js"></script> --><p>#SSR  </p><p>教程很简单，整个教程分三步：</p><p>第一步：购买VPS服务器</p><p>第二步：一键部署VPS服务器</p><p>第三步：一键加速VPS服务器 （谷歌BBR加速，推荐）</p><p>第一步：购买VPS服务器</p><p>VPS服务器需要选择国外的，首选国际知名的vultr，速度不错、稳定且性价比高，按小时计费，能够随时开通和删除服务器，新服务器即是新ip。</p><p>vultr注册地址： <a href="http://www.vultr.com（全球15个服务器位置可选，KVM框架，最低2.5美元/月。）" target="_blank" rel="noopener">http://www.vultr.com（全球15个服务器位置可选，KVM框架，最低2.5美元/月。）</a></p><p>虽然是英文界面，但是现在的浏览器都有网页翻译功能，鼠标点击右键，选择网页翻译即可翻译成中文。</p><p>注册并邮件激活账号，充值后即可购买服务器。充值方式是paypal（首选）或支付宝，使用paypal有银行卡（包括信用卡）即可。paypal注册地址：<a href="https://www.paypal.com" target="_blank" rel="noopener">https://www.paypal.com</a> （paypal是国际知名的第三方支付服务商，注册一下账号，绑定银行卡即可购买国外商品）</p><p>2.5美元/月的服务器配置信息：单核 512M内存 20G SSD硬盘 带宽峰值100M 500G流量/月</p><p>5美元/月的服务器配置信息： 单核 1G内存 25G SSD硬盘 带宽峰值100M 1000G流量/月</p><p>10美元/月的服务器配置信息： 单核 2G内存 40G SSD硬盘 带宽峰值100M 2000G流量/月</p><p>20美元/月的服务器配置信息： 2cpu 4G内存 60G SSD硬盘 带宽峰值100M 3000G流量/月</p><p>40美元/月的服务器配置信息： 4cpu 8G内存 100G SSD硬盘 带宽峰值100M 4000G流量/月</p><p>vultr实际上是折算成小时来计费的，比如服务器是5美元1个月，那么每小时收费为5/30/24=0.0069美元 会自动从账号中扣费，只要保证账号有钱即可。如果你部署的服务器实测后速度不理想，你可以把它删掉（destroy），重新换个地区的服务器来部署，方便且实用。因为新的服务器就是新的ip，所以当ip被封时这个方法很有用。当ip被封时，为了保证新开的服务器ip和原先的ip不一样，先开新服务器，开好后再删除旧服务器即可。</p><p>计费从你开通服务器开始算的，不管你有没有使用，即使服务器处于关机状态仍然会计费，如果你没有开通服务器就不算。比如你今天早上开通了服务器，但你有事情，晚上才部署，那么这段时间是会计费的。同理，如果你早上删掉服务器，第二天才开通新的服务器，那么这段时间是不会计费的。在账号的Billing选项里可以看到账户余额。</p><p>温馨提醒：同样的服务器位置，不同的宽带类型和地区所搭建的账号的访问速度会不同，这与中国电信、中国联通、中国移动国际出口带宽和线路不同有关，所以以实测为准。可以先选定一个服务器位置来按照教程进行搭建，熟悉搭建方法，当账号搭建完成并进行了bbr加速后，测试下速度自己是否满意，如果满意那就用这个服务器位置的服务器。如果速度不太满意，就一次性开几台不同的服务器位置的服务器，然后按照同样的方法来进行搭建并测试，选择最优的，之后把其它的服务器删掉，按小时计费测试成本可以忽略。</p><p>账号充值如图：</p><p>开通服务器步骤如图：</p><p>选择vps操作系统时，不要选centos7系统！点击图中的CentOS几个字，会弹出centos6，然后选中centos6！entos7默认的防火墙可能会干扰ssr的正常连接！<br>接下来这一步是开启vps的ipv6 ip，选填项。如果你的电脑系统可以用ipv6，那么可以勾选此项。大多数用户没有这个需求，但有一些用户可能会用到，所以补充了这部分内容。</p><p>完成购买后，找到系统的密码记下来，部署服务器时需要用到。vps系统（推荐centos6）的密码获取方法如下图：</p><p>如果你开启了vps的ipv6，那么在后台的settings选项可以找到服务器的ipv6 ip。在部署SSR账号时，你用ipv6 ip就行。整个部署及使用过程中，记得把电脑系统开启ipv6喔。</p><p>删掉服务器步骤如下图：</p><p>第二步：部署VPS服务器</p><p>购买服务器后，需要部署一下。因为你买的是虚拟东西，而且又远在国外，我们需要一个叫Xshell的软件来远程部署。Xshell windows版下载地址：</p><p>国外云盘1下载</p><p>国外云盘2下载 提取密码：666</p><p>国外云盘3下载 密码：123</p><p>如果你是苹果电脑操作系统，更简单，无需下载xshell，系统可以直接连接VPS。打开终端（Terminal），输入ssh root@ip 其中“ip”替换成你VPS的ip, 按回车键，然后复制粘贴密码，按回车键即可登录。粘贴密码时有可能不显示密码，但不影响， 参考设置方法 如果不能用MAC自带的终端连接的话，直接网上搜“MAC连接SSH的软件”，有很多，然后通过软件来连接vps服务器就行，具体操作方式参考windows xshell。</p><p>部署教程：</p><p>下载xshell软件并安装后，打开软件</p><p>选择文件，新建</p><p>随便取个名字，然后把你的服务器ip填上</p><p>连接国外ip即服务器时，软件会先后提醒你输入用户名和密码，用户名默认都是root，密码是你购买的服务器系统的密码。</p><p>如果xshell连不上服务器，没有弹出让你输入用户名和密码的输入框，表明你开到的ip是一个被封的ip，遇到这种情况，重新开新的服务器，直到能用xshell连上为止，耐心点哦！如果同一个地区开了多台服务器还是不行的话，可以换其它地区。</p><p>连接成功后，会出现如上图所示，之后就可以复制粘贴代码部署了。</p><p>CentOS6/Debian6/Ubuntu14 ShadowsocksR一键部署管理脚本：</p><p>yum -y install wget</p><p>wget -N –no-check-certificate <a href="https://softs.fun/Bash/ssr.sh" target="_blank" rel="noopener">https://softs.fun/Bash/ssr.sh</a> &amp;&amp; chmod +x ssr.sh &amp;&amp; bash ssr.sh</p><p>备用脚本：</p><p>yum -y install wget</p><p>wget -N –no-check-certificate <a href="https://raw.githubusercontent.com/ToyoDAdoubi/doubi/master/ssr.sh" target="_blank" rel="noopener">https://raw.githubusercontent.com/ToyoDAdoubi/doubi/master/ssr.sh</a> &amp;&amp; chmod +x ssr.sh &amp;&amp; bash ssr.sh</p><p>———————————————————代码分割线————————————————</p><p>复制上面的代码到VPS服务器里，按回车键，脚本会自动安装，以后只需要运行这个快捷命令就可以出现下图的界面进行设置，快捷管理命令为：bash ssr.sh</p><p>如上图出现管理界面后，输入数字1来安装SSR服务端。如果输入1后不能进入下一步，那么请退出xshell，重新连接vps服务器，然后输入快捷管理命令bash ssr.sh 再尝试。</p><p>根据上图提示，依次输入自己想设置的端口和密码 (密码建议用复杂点的字母组合，端口号为40-65535之间的数字)，回车键用于确认</p><p>注：关于端口的设置，总的网络总端口有6万多个，理论上可以任意设置。但是有的地区需要设置特殊的端口才有效，一些特殊的端口比如80、143、443、1433、3306、3389、8080。</p><p>如上图，选择想设置的加密方式，比如10，按回车键确认</p><p>接下来是选择协议插件，如下图：</p><p>选择并确认后，会出现上图的界面，提示你是否选择兼容原版，这里的原版指的是SS客户端（SS客户端没有协议和混淆的选项），可以根据需求进行选择，演示选择y</p><p>之后进行混淆插件的设置。</p><p>注意：如果协议是origin，那么混淆也必须是plain；如果协议不是origin，那么混淆可以是任意的。有的地区需要把混淆设置成plain才好用。因为混淆不总是有效果，要看各地区的策略，有时候不混淆（plain）让其看起来像随机数据更好。（特别注意：tls 1.2_ticket_auth容易受到干扰！请选择除tls开头以外的其它混淆！！！）</p><p>进行混淆插件的设置后，会依次提示你对设备数、单线程限速和端口总限速进行设置，默认值是不进行限制，个人使用的话，选择默认即可，即直接敲回车键。</p><p>注意：关于限制设备数，这个协议必须是非原版且不兼容原版才有效，也就是必须使用SSR协议的情况下，才有效！</p><p>之后代码就正式自动部署了，到下图所示的位置，提示你下载文件，输入：y</p><p>耐心等待一会，出现下面的界面即部署完成：</p><p>根据上图就可以看到自己设置的SSR账号信息，包括IP、端口、密码、加密方式、协议插件、混淆插件，这些信息需要填入你的SSR客户端。如果之后想修改账号信息，直接输入快捷管理命令：bash ssr.sh 进入管理界面，选择相应的数字来进行一键修改。例如：</p><p>脚本演示结束。</p><p>此脚本是开机自动启动，部署一次即可。最后可以重启服务器确保部署生效（一般情况不重启也可以）。重启需要在命令栏里输入reboot ，输入命令后稍微等待一会服务器就会自动重启，一般重启过程需要2～5分钟，重启过程中Xshell会自动断开连接，等VPS重启好后才可以用Xshell软件进行连接。如果部署过程中卡在某个位置超过10分钟，可以用xshell软件断开，然后重新连接你的ip，再复制代码进行部署。</p><p>第三步：一键加速VPS服务器</p><p>此加速教程为谷歌BBR加速,Vultr的服务器框架可以装BBR加速，加速后对速度的提升很明显，所以推荐部署加速脚本。该加速方法是开机自动启动，部署一次就可以了。</p><p>按照第二步的步骤，连接服务器ip，登录成功后，在命令栏里粘贴以下代码：</p><p>【谷歌BBR加速教程】</p><p>yum -y install wget</p><p>wget –no-check-certificate <a href="https://github.com/teddysun/across/raw/master/bbr.sh" target="_blank" rel="noopener">https://github.com/teddysun/across/raw/master/bbr.sh</a></p><p>chmod +x bbr.sh</p><p>./bbr.sh</p><p>把上面整个代码复制后粘贴进去，不动的时候按回车，然后耐心等待，最后重启vps服务器即可。</p><p>演示开始，如图：</p><p>复制并粘贴代码后，按回车键确认</p><p>如下图提示，按任意键继续部署</p><p>部署到上图这个位置的时候，等待3～6分钟</p><p>最后输入y重启服务器，如果输入y提示command not found ，接着输入reboot来重启服务器，确保加速生效，bbr加速脚本是开机自动启动，装一次就可以了。</p><p>购买vps服务器后，ip有了，通过部署，端口、密码、加密方式、协议和混淆也有了，最后将这些信息填入SSR客户端就可以访问外网啦。</p><p>有了账号后，打开SSR客户端，填上信息，这里以windows版的SSR客户端为例子：</p><p>在对应的位置，填上服务器ip、服务器端口、密码、加密方式、协议和混淆，最后将浏览器的代理设置为（http）127.0.0.1和1080即可。账号的端口号就是你自己设置的，而要上网的浏览器的端口号是1080，固定的，谷歌浏览器可以通过 SwitchyOmega 插件来设置。</p><p>启动SSR客户端后，右键SSR客户端图标，选择第一个“系统代理模式”，里面有3个子选项，选择”全局模式“，之后就可以用浏览器设置好了的代理模式（http）127.0.0.1和1080翻墙，此模式下所有的网站都会走SSR代理。（适合新手）</p><p>ssr9000</p><p>方法二<br>最近准备新安装一个。发现上面执行安装时，出错，安装不下去，<br>执行以下命令</p><p>wget –no-check-certificate <a href="https://freed.ga/github/shadowsocksR.sh" target="_blank" rel="noopener">https://freed.ga/github/shadowsocksR.sh</a>; bash shadowsocksR.sh<br>若提示：wget :command not found<br>请执行：yum install wget -y<br>然后再按照提示走就行了</p><p>QQ截图20180802123036</p><p>这张图注意保存<br>走到这一步，还有些不够，网速很慢，几乎慢到连不到网，所以进行第三步。</p><p>锐速安装<br>一键更换内核脚本（Vultr需先执行此脚本）</p><p>wget -N –no-check-certificate <a href="https://freed.ga/kernel/ruisu.sh" target="_blank" rel="noopener">https://freed.ga/kernel/ruisu.sh</a> &amp;&amp; bash ruisu.sh<br>脚本安装需要1-3分钟，耐心等待服务器重启，服务器重启之后，重新连接继续安装就行了。</p><p>锐速安装脚本</p><p>wget -N –no-check-certificate <a href="https://github.com/91yun/serverspeeder/raw/master/serverspeeder.sh" target="_blank" rel="noopener">https://github.com/91yun/serverspeeder/raw/master/serverspeeder.sh</a> &amp;&amp; bash serverspeeder.sh<br>QQ截图20180802123416</p><p>出现这些就算大功告成了。电脑连接可查看 上面连接教程就行了  </p><hr>]]></content>
      
      
      <categories>
          
          <category> 黑科技 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ssr </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
